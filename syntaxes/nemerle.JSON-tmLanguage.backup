{
  "name": "Nemerle",
  "scopeName": "source.nemerle",
  "fileTypes": [
    "n"
  ],
  "uuid": "6FE37C5B-55AC-4F1B-A0EC-C421B84D78C3",
  "patterns": [
    {
      "include": "#preprocessor"
    },
    {
      "include": "#comment"
    },
    {
      "include": "#directives"
    },
    {
      "include": "#declarations"
    },
    {
      "include": "#script-top-level"
    }
  ],
  "repository": {
    "directives": {
      "patterns": [
        {
          "include": "#extern-alias-directive"
        },
        {
          "include": "#using-directive"
        },
        {
          "include": "#attribute-section"
        },
        {
          "include": "#punctuation-semicolon"
        }
      ]
    },
    "declarations": {
      "patterns": [
        {
          "include": "#namespace-declaration"
        },
        {
          "include": "#type-declarations"
        },
        {
          "include": "#punctuation-semicolon"
        }
      ]
    },
    "script-top-level": {
      "patterns": [
        {
          "include": "#method-declaration"
        },
        {
          "include": "#statement"
        },
        {
          "include": "#punctuation-semicolon"
        }
      ]
    },
    "type-declarations": {
      "patterns": [
        {
          "include": "#preprocessor"
        },
        {
          "include": "#comment"
        },
        {
          "include": "#storage-modifier"
        },
        {
          "include": "#class-declaration"
        },
        {
          "include": "#delegate-declaration"
        },
        {
          "include": "#enum-declaration"
        },
        {
          "include": "#interface-declaration"
        },
        {
          "include": "#struct-declaration"
        },
        {
          "include": "#attribute-section"
        },
        {
          "include": "#punctuation-semicolon"
        }
      ]
    },
    "class-or-struct-members": {
      "patterns": [
        {
          "include": "#preprocessor"
        },
        {
          "include": "#comment"
        },
        {
          "include": "#storage-modifier"
        },
        {
          "include": "#type-declarations"
        },
        {
          "include": "#field-declaration"
        },
        {
          "include": "#event-declaration"
        },
        {
          "include": "#property-declaration"
        },
        {
          "include": "#indexer-declaration"
        },
        {
          "include": "#variable-initializer"
        },
        {
          "include": "#constructor-declaration"
        },
        {
          "include": "#destructor-declaration"
        },
        {
          "include": "#operator-declaration"
        },
        {
          "include": "#conversion-operator-declaration"
        },
        {
          "include": "#method-declaration"
        },
        {
          "include": "#attribute-section"
        },
        {
          "include": "#punctuation-semicolon"
        }
      ]
    },
    "interface-members": {
      "patterns": [
        {
          "include": "#preprocessor"
        },
        {
          "include": "#comment"
        },
        {
          "include": "#event-declaration"
        },
        {
          "include": "#property-declaration"
        },
        {
          "include": "#indexer-declaration"
        },
        {
          "include": "#method-declaration"
        },
        {
          "include": "#attribute-section"
        },
        {
          "include": "#punctuation-semicolon"
        }
      ]
    },
    "statement": {
      "patterns": [
        {
          "include": "#preprocessor"
        },
        {
          "include": "#comment"
        },
        {
          "include": "#while-statement"
        },
        {
          "include": "#do-statement"
        },
        {
          "include": "#for-statement"
        },
        {
          "include": "#foreach-statement"
        },
        {
          "include": "#if-statement"
        },
        {
          "include": "#else-part"
        },
        {
          "include": "#switch-statement"
        },
        {
          "include": "#goto-statement"
        },
        {
          "include": "#return-statement"
        },
        {
          "include": "#break-or-continue-statement"
        },
        {
          "include": "#throw-statement"
        },
        {
          "include": "#yield-statement"
        },
        {
          "include": "#await-statement"
        },
        {
          "include": "#try-statement"
        },
        {
          "include": "#checked-unchecked-statement"
        },
        {
          "include": "#lock-statement"
        },
        {
          "include": "#using-statement"
        },
        {
          "include": "#labeled-statement"
        },
        {
          "include": "#local-declaration"
        },
        {
          "include": "#block"
        },
        {
          "include": "#expression"
        },
        {
          "include": "#punctuation-semicolon"
        }
      ]
    },
    "expression": {
      "patterns": [
        {
          "include": "#preprocessor"
        },
        {
          "include": "#comment"
        },
        {
          "include": "#checked-unchecked-expression"
        },
        {
          "include": "#typeof-or-default-expression"
        },
        {
          "include": "#nameof-expression"
        },
        {
          "include": "#throw-expression"
        },
        {
          "include": "#interpolated-string"
        },
        {
          "include": "#verbatim-interpolated-string"
        },
        {
          "include": "#this-or-base-expression"
        },
        {
          "include": "#conditional-operator"
        },
        {
          "include": "#expression-operators"
        },
        {
          "include": "#await-expression"
        },
        {
          "include": "#query-expression"
        },
        {
          "include": "#as-expression"
        },
        {
          "include": "#is-expression"
        },
        {
          "include": "#anonymous-method-expression"
        },
        {
          "include": "#object-creation-expression"
        },
        {
          "include": "#array-creation-expression"
        },
        {
          "include": "#anonymous-object-creation-expression"
        },
        {
          "include": "#invocation-expression"
        },
        {
          "include": "#member-access-expression"
        },
        {
          "include": "#element-access-expression"
        },
        {
          "include": "#cast-expression"
        },
        {
          "include": "#literal"
        },
        {
          "include": "#parenthesized-expression"
        },
        {
          "include": "#tuple-deconstruction-assignment"
        },
        {
          "include": "#initializer-expression"
        },
        {
          "include": "#identifier"
        }
      ]
    },
    "extern-alias-directive": {
      "begin": "\\s*(extern)\\b\\s*(alias)\\b\\s*([_[:alpha:]][_[:alnum:]]*)",
      "beginCaptures": {
        "1": {
          "name": "keyword.other.extern.nemerle"
        },
        "2": {
          "name": "keyword.other.alias.nemerle"
        },
        "3": {
          "name": "variable.other.alias.nemerle"
        }
      },
      "end": "(?=;)"
    },
    "using-directive": {
      "patterns": [
        {
          "begin": "\\b(using)\\b\\s+(static)\\s+",
          "beginCaptures": {
            "1": {
              "name": "keyword.other.using.nemerle"
            },
            "2": {
              "name": "keyword.other.static.nemerle"
            }
          },
          "end": "(?=;)",
          "patterns": [
            {
              "include": "#type"
            }
          ]
        },
        {
          "begin": "\\b(using)\\s+(?=([_[:alpha:]][_[:alnum:]]*)\\s*=)",
          "beginCaptures": {
            "1": {
              "name": "keyword.other.using.nemerle"
            },
            "2": {
              "name": "entity.name.type.alias.nemerle"
            }
          },
          "end": "(?=;)",
          "patterns": [
            {
              "include": "#comment"
            },
            {
              "include": "#type"
            },
            {
              "include": "#operator-assignment"
            }
          ]
        },
        {
          "begin": "\\b(using)\\s*",
          "beginCaptures": {
            "1": {
              "name": "keyword.other.using.nemerle"
            }
          },
          "end": "(?=;)",
          "patterns": [
            {
              "include": "#comment"
            },
            {
              "name": "entity.name.type.namespace.nemerle",
              "match": "[_[:alpha:]][_[:alnum:]]*"
            },
            {
              "include": "#operator-assignment"
            }
          ]
        }
      ]
    },
    "attribute-section": {
      "begin": "(\\[)(assembly|module|field|event|method|param|property|return|type)?(\\:)?",
      "beginCaptures": {
        "1": {
          "name": "punctuation.squarebracket.open.nemerle"
        },
        "2": {
          "name": "keyword.other.attribute-specifier.nemerle"
        },
        "3": {
          "name": "punctuation.separator.colon.nemerle"
        }
      },
      "end": "(\\])",
      "endCaptures": {
        "1": {
          "name": "punctuation.squarebracket.close.nemerle"
        }
      },
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#attribute"
        },
        {
          "include": "#punctuation-comma"
        }
      ]
    },
    "attribute": {
      "patterns": [
        {
          "include": "#type-name"
        },
        {
          "include": "#attribute-arguments"
        }
      ]
    },
    "attribute-arguments": {
      "begin": "(\\()",
      "beginCaptures": {
        "1": {
          "name": "punctuation.parenthesis.open.nemerle"
        }
      },
      "end": "(\\))",
      "endCaptures": {
        "1": {
          "name": "punctuation.parenthesis.close.nemerle"
        }
      },
      "patterns": [
        {
          "include": "#attribute-named-argument"
        },
        {
          "include": "#expression"
        },
        {
          "include": "#punctuation-comma"
        }
      ]
    },
    "attribute-named-argument": {
      "begin": "([_[:alpha:]][_[:alnum:]]*)\\s*(?==)",
      "beginCaptures": {
        "1": {
          "name": "entity.name.variable.property.nemerle"
        }
      },
      "end": "(?=(,|\\)))",
      "patterns": [
        {
          "include": "#operator-assignment"
        },
        {
          "include": "#expression"
        }
      ]
    },
    "namespace-declaration": {
      "begin": "\\b(namespace)\\s+",
      "beginCaptures": {
        "1": {
          "name": "keyword.other.namespace.nemerle"
        }
      },
      "end": "(?<=\\})",
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "name": "entity.name.type.namespace.nemerle",
          "match": "[_[:alpha:]][_[:alnum:]]*"
        },
        {
          "include": "#punctuation-accessor"
        },
        {
          "begin": "\\{",
          "beginCaptures": {
            "0": {
              "name": "punctuation.curlybrace.open.nemerle"
            }
          },
          "end": "\\}",
          "endCaptures": {
            "0": {
              "name": "punctuation.curlybrace.close.nemerle"
            }
          },
          "patterns": [
            {
              "include": "#declarations"
            },
            {
              "include": "#using-directive"
            },
            {
              "include": "#punctuation-semicolon"
            }
          ]
        }
      ]
    },
    "storage-modifier": {
      "name": "storage.modifier.nemerle",
      "match": "(?<!\\.)\\b(new|public|protected|internal|private|abstract|virtual|override|sealed|static|partial|readonly|volatile|const|extern|async|unsafe)\\b"
    },
    "class-declaration": {
      "begin": "(?=\\bclass\\b)",
      "end": "(?<=\\})",
      "patterns": [
        {
          "begin": "(?x)\n\\b(class)\\b\\s+\n([_[:alpha:]][_[:alnum:]]*)\\s*",
          "beginCaptures": {
            "1": {
              "name": "keyword.other.class.nemerle"
            },
            "2": {
              "name": "entity.name.type.class.nemerle"
            }
          },
          "end": "(?=\\{)",
          "patterns": [
            {
              "include": "#comment"
            },
            {
              "include": "#type-parameter-list"
            },
            {
              "include": "#base-types"
            },
            {
              "include": "#generic-constraints"
            }
          ]
        },
        {
          "begin": "\\{",
          "beginCaptures": {
            "0": {
              "name": "punctuation.curlybrace.open.nemerle"
            }
          },
          "end": "\\}",
          "endCaptures": {
            "0": {
              "name": "punctuation.curlybrace.close.nemerle"
            }
          },
          "patterns": [
            {
              "include": "#class-or-struct-members"
            }
          ]
        },
        {
          "include": "#preprocessor"
        },
        {
          "include": "#comment"
        }
      ]
    },
    "delegate-declaration": {
      "begin": "(?x)\n(?:\\b(delegate)\\b)\\s+\n(?<type-name>\n  (?:\n    (?:ref\\s+)?   # ref return\n    (?:\n      (?:(?<identifier>[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n      (?<name-and-type-args> # identifier + type arguments (if any)\n        \\g<identifier>\\s*\n        (?<type-args>\\s*\\[(?:[^\\[\\]]|\\g<type-args>)+\\]\\s*)?\n      )\n      (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?\n      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n    )\n    (?:\\s*\\*\\s*)* # pointer suffix?\n    (?:\\s*\\?\\s*)? # nullable suffix?\n    (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?\n  )\n)\\s+\n(\\g<identifier>)\\s*\n(\\[([^\\[\\]]+)\\])?\\s*\n(?=\\()",
      "beginCaptures": {
        "1": {
          "name": "keyword.other.delegate.nemerle"
        },
        "2": {
          "patterns": [
            {
              "include": "#type"
            }
          ]
        },
        "7": {
          "name": "entity.name.type.delegate.nemerle"
        },
        "8": {
          "patterns": [
            {
              "include": "#type-parameter-list"
            }
          ]
        }
      },
      "end": "(?=;)",
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#parenthesized-parameter-list"
        },
        {
          "include": "#generic-constraints"
        }
      ]
    },
    "enum-declaration": {
      "begin": "(?=\\benum\\b)",
      "end": "(?<=\\})",
      "patterns": [
        {
          "begin": "(?=enum)",
          "end": "(?=\\{)",
          "patterns": [
            {
              "include": "#comment"
            },
            {
              "match": "(enum)\\s+([_[:alpha:]][_[:alnum:]]*)",
              "captures": {
                "1": {
                  "name": "keyword.other.enum.nemerle"
                },
                "2": {
                  "name": "entity.name.type.enum.nemerle"
                }
              }
            },
            {
              "begin": ":",
              "beginCaptures": {
                "0": {
                  "name": "punctuation.separator.colon.nemerle"
                }
              },
              "end": "(?=\\{)",
              "patterns": [
                {
                  "include": "#type"
                }
              ]
            }
          ]
        },
        {
          "begin": "\\{",
          "beginCaptures": {
            "0": {
              "name": "punctuation.curlybrace.open.nemerle"
            }
          },
          "end": "\\}",
          "endCaptures": {
            "0": {
              "name": "punctuation.curlybrace.close.nemerle"
            }
          },
          "patterns": [
            {
              "include": "#preprocessor"
            },
            {
              "include": "#comment"
            },
            {
              "include": "#attribute-section"
            },
            {
              "include": "#punctuation-comma"
            },
            {
              "begin": "[_[:alpha:]][_[:alnum:]]*",
              "beginCaptures": {
                "0": {
                  "name": "entity.name.variable.enum-member.nemerle"
                }
              },
              "end": "(?=(,|\\}))",
              "patterns": [
                {
                  "include": "#comment"
                },
                {
                  "include": "#variable-initializer"
                }
              ]
            }
          ]
        },
        {
          "include": "#preprocessor"
        },
        {
          "include": "#comment"
        }
      ]
    },
    "interface-declaration": {
      "begin": "(?=\\binterface\\b)",
      "end": "(?<=\\})",
      "patterns": [
        {
          "begin": "(?x)\n(interface)\\b\\s+\n([_[:alpha:]][_[:alnum:]]*)",
          "beginCaptures": {
            "1": {
              "name": "keyword.other.interface.nemerle"
            },
            "2": {
              "name": "entity.name.type.interface.nemerle"
            }
          },
          "end": "(?=\\{)",
          "patterns": [
            {
              "include": "#comment"
            },
            {
              "include": "#type-parameter-list"
            },
            {
              "include": "#base-types"
            },
            {
              "include": "#generic-constraints"
            }
          ]
        },
        {
          "begin": "\\{",
          "beginCaptures": {
            "0": {
              "name": "punctuation.curlybrace.open.nemerle"
            }
          },
          "end": "\\}",
          "endCaptures": {
            "0": {
              "name": "punctuation.curlybrace.close.nemerle"
            }
          },
          "patterns": [
            {
              "include": "#interface-members"
            }
          ]
        },
        {
          "include": "#preprocessor"
        },
        {
          "include": "#comment"
        }
      ]
    },
    "struct-declaration": {
      "begin": "(?=\\bstruct\\b)",
      "end": "(?<=\\})",
      "patterns": [
        {
          "begin": "(?x)\n(struct)\\b\\s+\n([_[:alpha:]][_[:alnum:]]*)",
          "beginCaptures": {
            "1": {
              "name": "keyword.other.struct.nemerle"
            },
            "2": {
              "name": "entity.name.type.struct.nemerle"
            }
          },
          "end": "(?=\\{)",
          "patterns": [
            {
              "include": "#comment"
            },
            {
              "include": "#type-parameter-list"
            },
            {
              "include": "#base-types"
            },
            {
              "include": "#generic-constraints"
            }
          ]
        },
        {
          "begin": "\\{",
          "beginCaptures": {
            "0": {
              "name": "punctuation.curlybrace.open.nemerle"
            }
          },
          "end": "\\}",
          "endCaptures": {
            "0": {
              "name": "punctuation.curlybrace.close.nemerle"
            }
          },
          "patterns": [
            {
              "include": "#class-or-struct-members"
            }
          ]
        },
        {
          "include": "#preprocessor"
        },
        {
          "include": "#comment"
        }
      ]
    },
    "type-parameter-list": {
      "begin": "\\[",
      "beginCaptures": {
        "0": {
          "name": "punctuation.definition.typeparameters.begin.nemerle"
        }
      },
      "end": "\\]",
      "endCaptures": {
        "0": {
          "name": "punctuation.definition.typeparameters.end.nemerle"
        }
      },
      "patterns": [
        {
          "match": "\\b(in|out)\\b",
          "captures": {
            "1": {
              "name": "storage.modifier.nemerle"
            }
          }
        },
        {
          "match": "\\b([_[:alpha:]][_[:alnum:]]*)\\b",
          "captures": {
            "1": {
              "name": "entity.name.type.type-parameter.nemerle"
            }
          }
        },
        {
          "include": "#comment"
        },
        {
          "include": "#punctuation-comma"
        },
        {
          "include": "#attribute-section"
        }
      ]
    },
    "base-types": {
      "begin": ":",
      "beginCaptures": {
        "0": {
          "name": "punctuation.separator.colon.nemerle"
        }
      },
      "end": "(?=\\{|where)",
      "patterns": [
        {
          "include": "#type"
        },
        {
          "include": "#punctuation-comma"
        },
        {
          "include": "#preprocessor"
        }
      ]
    },
    "generic-constraints": {
      "begin": "(where)\\s+([_[:alpha:]][_[:alnum:]]*)\\s*(:)",
      "beginCaptures": {
        "1": {
          "name": "keyword.other.where.nemerle"
        },
        "2": {
          "name": "entity.name.type.nemerle"
        },
        "3": {
          "name": "punctuation.separator.colon.nemerle"
        }
      },
      "end": "(?=\\{|where|;)",
      "patterns": [
        {
          "name": "keyword.other.class.nemerle",
          "match": "\\bclass\\b"
        },
        {
          "name": "keyword.other.struct.nemerle",
          "match": "\\bstruct\\b"
        },
        {
          "match": "(new)\\s*(\\()\\s*(\\))",
          "captures": {
            "1": {
              "name": "keyword.other.new.nemerle"
            },
            "2": {
              "name": "punctuation.parenthesis.open.nemerle"
            },
            "3": {
              "name": "punctuation.parenthesis.close.nemerle"
            }
          }
        },
        {
          "include": "#type"
        },
        {
          "include": "#punctuation-comma"
        },
        {
          "include": "#generic-constraints"
        }
      ]
    },
    "field-declaration": {
      "begin": "(?x)\n(?<type-name>\n  (?:\n    (?:\n      (?:(?<identifier>[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n      (?<name-and-type-args> # identifier + type arguments (if any)\n        \\g<identifier>\\s*\n        (?<type-args>\\s*\\[(?:[^\\[\\]]|\\g<type-args>)+\\]\\s*)?\n      )\n      (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?\n      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n    )\n    (?:\\s*\\*\\s*)* # pointer suffix?\n    (?:\\s*\\?\\s*)? # nullable suffix?\n    (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?\n  )\n)\\s+\n(\\g<identifier>)\\s* # first field name\n(?!=>|==)(?=,|;|=|$)",
      "beginCaptures": {
        "1": {
          "patterns": [
            {
              "include": "#type"
            }
          ]
        },
        "6": {
          "name": "entity.name.variable.field.nemerle"
        }
      },
      "end": "(?=;)",
      "patterns": [
        {
          "name": "entity.name.variable.field.nemerle",
          "match": "[_[:alpha:]][_[:alnum:]]*"
        },
        {
          "include": "#punctuation-comma"
        },
        {
          "include": "#comment"
        },
        {
          "include": "#variable-initializer"
        },
        {
          "include": "#class-or-struct-members"
        }
      ]
    },
    "property-declaration": {
      "begin": "(?x)\n(?!.*\\b(?:class|interface|struct|enum|event)\\b)\\s*\n(?<return-type>\n  (?<type-name>\n    (?:\n      (?:ref\\s+)?   # ref return\n      (?:\n        (?:(?<identifier>[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n        (?<name-and-type-args> # identifier + type arguments (if any)\n          \\g<identifier>\\s*\n          (?<type-args>\\s*\\[(?:[^\\[\\]]|\\g<type-args>)+\\]\\s*)?\n        )\n        (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?\n        (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n      )\n      (?:\\s*\\*\\s*)* # pointer suffix?\n      (?:\\s*\\?\\s*)? # nullable suffix?\n      (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?\n    )\n  )\\s+\n)\n(?<interface-name>\\g<type-name>\\s*\\.\\s*)?\n(?<property-name>\\g<identifier>)\\s*\n(?=\\{|=>|$)",
      "beginCaptures": {
        "1": {
          "patterns": [
            {
              "include": "#type"
            }
          ]
        },
        "7": {
          "patterns": [
            {
              "include": "#type"
            },
            {
              "include": "#punctuation-accessor"
            }
          ]
        },
        "8": {
          "name": "entity.name.variable.property.nemerle"
        }
      },
      "end": "(?<=\\})|(?=;)",
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#property-accessors"
        },
        {
          "include": "#expression-body"
        },
        {
          "include": "#variable-initializer"
        },
        {
          "include": "#class-or-struct-members"
        }
      ]
    },
    "indexer-declaration": {
      "begin": "(?x)\n(?<return-type>\n  (?<type-name>\n    (?:\n      (?:ref\\s+)?   # ref return\n      (?:\n        (?:(?<identifier>[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n        (?<name-and-type-args> # identifier + type arguments (if any)\n          \\g<identifier>\\s*\n          (?<type-args>\\s*\\[(?:[^\\[\\]]|\\g<type-args>)+\\]\\s*)?\n        )\n        (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?\n        (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n      )\n      (?:\\s*\\*\\s*)* # pointer suffix?\n      (?:\\s*\\?\\s*)? # nullable suffix?\n      (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?\n    )\n  )\\s+\n)\n(?<interface-name>\\g<type-name>\\s*\\.\\s*)?\n(?<indexer-name>this)\\s*\n(?=\\[)",
      "beginCaptures": {
        "1": {
          "patterns": [
            {
              "include": "#type"
            }
          ]
        },
        "7": {
          "patterns": [
            {
              "include": "#type"
            },
            {
              "include": "#punctuation-accessor"
            }
          ]
        },
        "8": {
          "name": "keyword.other.this.nemerle"
        }
      },
      "end": "(?<=\\})|(?=;)",
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#bracketed-parameter-list"
        },
        {
          "include": "#property-accessors"
        },
        {
          "include": "#expression-body"
        },
        {
          "include": "#variable-initializer"
        }
      ]
    },
    "event-declaration": {
      "begin": "(?x)\n\\b(event)\\b\\s*\n(?<return-type>\n  (?<type-name>\n    (?:\n      (?:\n        (?:(?<identifier>[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n        (?<name-and-type-args> # identifier + type arguments (if any)\n          \\g<identifier>\\s*\n          (?<type-args>\\s*\\[(?:[^\\[\\]]|\\g<type-args>)+\\]\\s*)?\n        )\n        (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?\n        (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n      )\n      (?:\\s*\\*\\s*)* # pointer suffix?\n      (?:\\s*\\?\\s*)? # nullable suffix?\n      (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?\n    )\n  )\\s+\n)\n(?<interface-name>\\g<type-name>\\s*\\.\\s*)?\n(?<event-names>\\g<identifier>(?:\\s*,\\s*\\g<identifier>)*)\\s*\n(?=\\{|;|$)",
      "beginCaptures": {
        "1": {
          "name": "keyword.other.event.nemerle"
        },
        "2": {
          "patterns": [
            {
              "include": "#type"
            }
          ]
        },
        "8": {
          "patterns": [
            {
              "include": "#type"
            },
            {
              "include": "#punctuation-accessor"
            }
          ]
        },
        "9": {
          "patterns": [
            {
              "name": "entity.name.variable.event.nemerle",
              "match": "[_[:alpha:]][_[:alnum:]]*"
            },
            {
              "include": "#punctuation-comma"
            }
          ]
        }
      },
      "end": "(?<=\\})|(?=;)",
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#event-accessors"
        },
        {
          "include": "#punctuation-comma"
        }
      ]
    },
    "property-accessors": {
      "begin": "\\{",
      "beginCaptures": {
        "0": {
          "name": "punctuation.curlybrace.open.nemerle"
        }
      },
      "end": "\\}",
      "endCaptures": {
        "0": {
          "name": "punctuation.curlybrace.close.nemerle"
        }
      },
      "patterns": [
        {
          "name": "storage.modifier.nemerle",
          "match": "\\b(private|protected|internal)\\b"
        },
        {
          "name": "keyword.other.get.nemerle",
          "match": "\\b(get)\\b"
        },
        {
          "name": "keyword.other.set.nemerle",
          "match": "\\b(set)\\b"
        },
        {
          "include": "#comment"
        },
        {
          "include": "#attribute-section"
        },
        {
          "include": "#expression-body"
        },
        {
          "include": "#block"
        },
        {
          "include": "#punctuation-semicolon"
        }
      ]
    },
    "event-accessors": {
      "begin": "\\{",
      "beginCaptures": {
        "0": {
          "name": "punctuation.curlybrace.open.nemerle"
        }
      },
      "end": "\\}",
      "endCaptures": {
        "0": {
          "name": "punctuation.curlybrace.close.nemerle"
        }
      },
      "patterns": [
        {
          "name": "keyword.other.add.nemerle",
          "match": "\\b(add)\\b"
        },
        {
          "name": "keyword.other.remove.nemerle",
          "match": "\\b(remove)\\b"
        },
        {
          "include": "#comment"
        },
        {
          "include": "#attribute-section"
        },
        {
          "include": "#expression-body"
        },
        {
          "include": "#block"
        },
        {
          "include": "#punctuation-semicolon"
        }
      ]
    },
    "method-declaration": {
      "begin": "(?x)\n(?<return-type>\n  (?<type-name>\n    (?:\n      (?:ref\\s+)?   # ref return\n      (?:\n        (?:(?<identifier>[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n        (?<name-and-type-args> # identifier + type arguments (if any)\n          \\g<identifier>\\s*\n          (?<type-args>\\s*\\[(?:[^\\[\\]]|\\g<type-args>)+\\]\\s*)?\n        )\n        (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?\n        (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n      )\n      (?:\\s*\\*\\s*)* # pointer suffix?\n      (?:\\s*\\?\\s*)? # nullable suffix?\n      (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?\n    )\n  )\\s+\n)\n(?<interface-name>\\g<type-name>\\s*\\.\\s*)?\n(\\g<identifier>)\\s*\n(\\[([^\\[\\]]+)\\])?\\s*\n(?=\\()",
      "beginCaptures": {
        "1": {
          "patterns": [
            {
              "include": "#type"
            }
          ]
        },
        "7": {
          "patterns": [
            {
              "include": "#type"
            },
            {
              "include": "#punctuation-accessor"
            }
          ]
        },
        "8": {
          "name": "entity.name.function.nemerle"
        },
        "9": {
          "patterns": [
            {
              "include": "#type-parameter-list"
            }
          ]
        }
      },
      "end": "(?<=\\})|(?=;)",
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#parenthesized-parameter-list"
        },
        {
          "include": "#generic-constraints"
        },
        {
          "include": "#expression-body"
        },
        {
          "include": "#block"
        }
      ]
    },
    "constructor-declaration": {
      "begin": "(?=[_[:alpha:]][_[:alnum:]]*\\s*\\()",
      "end": "(?<=\\})|(?=;)",
      "patterns": [
        {
          "match": "\\b([_[:alpha:]][_[:alnum:]]*)\\b",
          "captures": {
            "1": {
              "name": "entity.name.function.nemerle"
            }
          }
        },
        {
          "begin": "(:)",
          "beginCaptures": {
            "1": {
              "name": "punctuation.separator.colon.nemerle"
            }
          },
          "end": "(?=\\{|=>)",
          "patterns": [
            {
              "include": "#constructor-initializer"
            }
          ]
        },
        {
          "include": "#parenthesized-parameter-list"
        },
        {
          "include": "#preprocessor"
        },
        {
          "include": "#comment"
        },
        {
          "include": "#expression-body"
        },
        {
          "include": "#block"
        }
      ]
    },
    "constructor-initializer": {
      "begin": "\\b(?:(base)|(this))\\b\\s*(?=\\()",
      "beginCaptures": {
        "1": {
          "name": "keyword.other.base.nemerle"
        },
        "2": {
          "name": "keyword.other.this.nemerle"
        }
      },
      "end": "(?<=\\))",
      "patterns": [
        {
          "include": "#argument-list"
        }
      ]
    },
    "destructor-declaration": {
      "begin": "(~)([_[:alpha:]][_[:alnum:]]*)\\s*(?=\\()",
      "beginCaptures": {
        "1": {
          "name": "punctuation.tilde.nemerle"
        },
        "2": {
          "name": "entity.name.function.nemerle"
        }
      },
      "end": "(?<=\\})|(?=;)",
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#parenthesized-parameter-list"
        },
        {
          "include": "#expression-body"
        },
        {
          "include": "#block"
        }
      ]
    },
    "operator-declaration": {
      "begin": "(?x)\n(?<type-name>\n  (?:\n    (?:ref\\s+)?   # ref return\n    (?:\n      (?:(?<identifier>[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n      (?<name-and-type-args> # identifier + type arguments (if any)\n        \\g<identifier>\\s*\n        (?<type-args>\\s*\\[(?:[^\\[\\]]|\\g<type-args>)+\\]\\s*)?\n      )\n      (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?\n      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n    )\n    (?:\\s*\\*\\s*)* # pointer suffix?\n    (?:\\s*\\?\\s*)? # nullable suffix?\n    (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?\n  )\n)\\s*\n(?<operator-keyword>(?:\\b(?:operator)))\\s*\n(?<operator>(?:\\+|-|\\*|/|%|&|\\||\\^|\\<\\<|\\>\\>|==|!=|\\>|\\<|\\>=|\\<=|!|~|\\+\\+|--|true|false))\\s*\n(?=\\()",
      "beginCaptures": {
        "1": {
          "patterns": [
            {
              "include": "#type"
            }
          ]
        },
        "6": {
          "name": "keyword.other.operator-decl.nemerle"
        },
        "7": {
          "name": "entity.name.function.nemerle"
        }
      },
      "end": "(?<=\\})|(?=;)",
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#parenthesized-parameter-list"
        },
        {
          "include": "#expression-body"
        },
        {
          "include": "#block"
        }
      ]
    },
    "conversion-operator-declaration": {
      "begin": "(?x)\n(?<explicit-or-implicit-keyword>(?:\\b(?:explicit|implicit)))\\s*\n(?<operator-keyword>(?:\\b(?:operator)))\\s*\n(?<type-name>\n  (?:\n    (?:ref\\s+)?   # ref return\n    (?:\n      (?:(?<identifier>[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n      (?<name-and-type-args> # identifier + type arguments (if any)\n        \\g<identifier>\\s*\n        (?<type-args>\\s*\\[(?:[^\\[\\]]|\\g<type-args>)+\\]\\s*)?\n      )\n      (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?\n      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n    )\n    (?:\\s*\\*\\s*)* # pointer suffix?\n    (?:\\s*\\?\\s*)? # nullable suffix?\n    (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?\n  )\n)\\s*\n(?=\\()",
      "beginCaptures": {
        "1": {
          "patterns": [
            {
              "match": "\\b(explicit)\\b",
              "captures": {
                "1": {
                  "name": "keyword.other.explicit.nemerle"
                }
              }
            },
            {
              "match": "\\b(implicit)\\b",
              "captures": {
                "1": {
                  "name": "keyword.other.implicit.nemerle"
                }
              }
            }
          ]
        },
        "2": {
          "name": "keyword.other.operator-decl.nemerle"
        },
        "3": {
          "patterns": [
            {
              "include": "#type"
            }
          ]
        }
      },
      "end": "(?<=\\})|(?=;)",
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#parenthesized-parameter-list"
        },
        {
          "include": "#expression-body"
        },
        {
          "include": "#block"
        }
      ]
    },
    "block": {
      "begin": "\\{",
      "beginCaptures": {
        "0": {
          "name": "punctuation.curlybrace.open.nemerle"
        }
      },
      "end": "\\}",
      "endCaptures": {
        "0": {
          "name": "punctuation.curlybrace.close.nemerle"
        }
      },
      "patterns": [
        {
          "include": "#statement"
        }
      ]
    },
    "variable-initializer": {
      "begin": "(?<!=|!)(=)(?!=|>)",
      "beginCaptures": {
        "1": {
          "name": "keyword.operator.assignment.nemerle"
        }
      },
      "end": "(?=[,\\)\\];}])",
      "patterns": [
        {
          "include": "#ref-modifier"
        },
        {
          "include": "#expression"
        }
      ]
    },
    "expression-body": {
      "begin": "=>",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.arrow.nemerle"
        }
      },
      "end": "(?=[,\\);}])",
      "patterns": [
        {
          "include": "#ref-modifier"
        },
        {
          "include": "#expression"
        }
      ]
    },
    "goto-statement": {
      "begin": "(?<!\\.)\\b(goto)\\b",
      "beginCaptures": {
        "1": {
          "name": "keyword.control.goto.nemerle"
        }
      },
      "end": "(?=;)",
      "patterns": [
        {
          "begin": "\\b(case)\\b",
          "beginCaptures": {
            "1": {
              "name": "keyword.control.case.nemerle"
            }
          },
          "end": "(?=;)",
          "patterns": [
            {
              "include": "#expression"
            }
          ]
        },
        {
          "match": "\\b(default)\\b",
          "captures": {
            "1": {
              "name": "keyword.control.default.nemerle"
            }
          }
        },
        {
          "name": "entity.name.label.nemerle",
          "match": "[_[:alpha:]][_[:alnum:]]*"
        }
      ]
    },
    "return-statement": {
      "begin": "(?<!\\.)\\b(return)\\b",
      "beginCaptures": {
        "1": {
          "name": "keyword.control.flow.return.nemerle"
        }
      },
      "end": "(?=;)",
      "patterns": [
        {
          "include": "#ref-modifier"
        },
        {
          "include": "#expression"
        }
      ]
    },
    "break-or-continue-statement": {
      "match": "(?<!\\.)\\b(?:(break)|(continue))\\b",
      "captures": {
        "1": {
          "name": "keyword.control.flow.break.nemerle"
        },
        "2": {
          "name": "keyword.control.flow.continue.nemerle"
        }
      }
    },
    "throw-statement": {
      "begin": "(?<!\\.)\\b(throw)\\b",
      "beginCaptures": {
        "1": {
          "name": "keyword.control.flow.throw.nemerle"
        }
      },
      "end": "(?=;)",
      "patterns": [
        {
          "include": "#expression"
        }
      ]
    },
    "yield-statement": {
      "patterns": [
        {
          "include": "#yield-return-statement"
        },
        {
          "include": "#yield-break-statement"
        }
      ]
    },
    "yield-return-statement": {
      "begin": "(?<!\\.)\\b(yield)\\b\\s*\\b(return)\\b",
      "beginCaptures": {
        "1": {
          "name": "keyword.control.flow.yield.nemerle"
        },
        "2": {
          "name": "keyword.control.flow.return.nemerle"
        }
      },
      "end": "(?=;)",
      "patterns": [
        {
          "include": "#expression"
        }
      ]
    },
    "yield-break-statement": {
      "match": "(?<!\\.)\\b(yield)\\b\\s*\\b(break)\\b",
      "captures": {
        "1": {
          "name": "keyword.control.flow.yield.nemerle"
        },
        "2": {
          "name": "keyword.control.flow.break.nemerle"
        }
      }
    },
    "await-statement": {
      "begin": "(?<!\\.)\\b(await)\\b",
      "beginCaptures": {
        "1": {
          "name": "keyword.other.await.nemerle"
        }
      },
      "end": "(?=;)",
      "patterns": [
        {
          "include": "#expression"
        }
      ]
    },
    "if-statement": {
      "begin": "(?<!\\.)\\b(if)\\b\\s*(?=\\()",
      "beginCaptures": {
        "1": {
          "name": "keyword.control.conditional.if.nemerle"
        }
      },
      "end": "(?<=\\})|(?=;)",
      "patterns": [
        {
          "begin": "\\(",
          "beginCaptures": {
            "0": {
              "name": "punctuation.parenthesis.open.nemerle"
            }
          },
          "end": "\\)",
          "endCaptures": {
            "0": {
              "name": "punctuation.parenthesis.close.nemerle"
            }
          },
          "patterns": [
            {
              "include": "#expression"
            }
          ]
        },
        {
          "include": "#statement"
        }
      ]
    },
    "else-part": {
      "begin": "(?<!\\.)\\b(else)\\b",
      "beginCaptures": {
        "1": {
          "name": "keyword.control.conditional.else.nemerle"
        }
      },
      "end": "(?<=\\})|(?=;)",
      "patterns": [
        {
          "include": "#statement"
        }
      ]
    },
    "switch-statement": {
      "begin": "(?<!\\.)\\b(switch)\\b\\s*(?=\\()",
      "beginCaptures": {
        "1": {
          "name": "keyword.control.switch.nemerle"
        }
      },
      "end": "(?<=\\})",
      "patterns": [
        {
          "begin": "\\(",
          "beginCaptures": {
            "0": {
              "name": "punctuation.parenthesis.open.nemerle"
            }
          },
          "end": "\\)",
          "endCaptures": {
            "0": {
              "name": "punctuation.parenthesis.close.nemerle"
            }
          },
          "patterns": [
            {
              "include": "#expression"
            }
          ]
        },
        {
          "begin": "\\{",
          "beginCaptures": {
            "0": {
              "name": "punctuation.curlybrace.open.nemerle"
            }
          },
          "end": "\\}",
          "endCaptures": {
            "0": {
              "name": "punctuation.curlybrace.close.nemerle"
            }
          },
          "patterns": [
            {
              "include": "#switch-label"
            },
            {
              "include": "#statement"
            }
          ]
        }
      ]
    },
    "switch-label": {
      "patterns": [
        {
          "begin": "(?<!\\.)\\b(case)\\b\\s+",
          "beginCaptures": {
            "1": {
              "name": "keyword.control.case.nemerle"
            }
          },
          "end": ":",
          "endCaptures": {
            "0": {
              "name": "punctuation.separator.colon.nemerle"
            }
          },
          "patterns": [
            {
              "include": "#expression"
            }
          ]
        },
        {
          "match": "(?<!\\.)\\b(default)\\b\\s*(:)",
          "captures": {
            "1": {
              "name": "keyword.control.default.nemerle"
            },
            "2": {
              "name": "punctuation.separator.colon.nemerle"
            }
          }
        }
      ]
    },
    "do-statement": {
      "begin": "(?<!\\.)\\b(do)\\b",
      "beginCaptures": {
        "1": {
          "name": "keyword.control.loop.do.nemerle"
        }
      },
      "end": "(?=;|})",
      "patterns": [
        {
          "include": "#statement"
        }
      ]
    },
    "while-statement": {
      "begin": "(?<!\\.)\\b(while)\\b\\s*(?=\\()",
      "beginCaptures": {
        "1": {
          "name": "keyword.control.loop.while.nemerle"
        }
      },
      "end": "(?<=\\})|(?=;)",
      "patterns": [
        {
          "begin": "\\(",
          "beginCaptures": {
            "0": {
              "name": "punctuation.parenthesis.open.nemerle"
            }
          },
          "end": "\\)",
          "endCaptures": {
            "0": {
              "name": "punctuation.parenthesis.close.nemerle"
            }
          },
          "patterns": [
            {
              "include": "#expression"
            }
          ]
        },
        {
          "include": "#statement"
        }
      ]
    },
    "for-statement": {
      "begin": "(?<!\\.)\\b(for)\\b\\s*(?=\\()",
      "beginCaptures": {
        "1": {
          "name": "keyword.control.loop.for.nemerle"
        }
      },
      "end": "(?<=\\})|(?=;)",
      "patterns": [
        {
          "begin": "\\(",
          "beginCaptures": {
            "0": {
              "name": "punctuation.parenthesis.open.nemerle"
            }
          },
          "end": "\\)",
          "endCaptures": {
            "0": {
              "name": "punctuation.parenthesis.close.nemerle"
            }
          },
          "patterns": [
            {
              "include": "#local-variable-declaration"
            },
            {
              "include": "#expression"
            },
            {
              "include": "#punctuation-comma"
            },
            {
              "include": "#punctuation-semicolon"
            }
          ]
        },
        {
          "include": "#statement"
        }
      ]
    },
    "foreach-statement": {
      "begin": "(?<!\\.)\\b(foreach)\\b\\s*(?=\\()",
      "beginCaptures": {
        "1": {
          "name": "keyword.control.loop.foreach.nemerle"
        }
      },
      "end": "(?<=\\})|(?=;)",
      "patterns": [
        {
          "begin": "\\(",
          "beginCaptures": {
            "0": {
              "name": "punctuation.parenthesis.open.nemerle"
            }
          },
          "end": "\\)",
          "endCaptures": {
            "0": {
              "name": "punctuation.parenthesis.close.nemerle"
            }
          },
          "patterns": [
            {
              "match": "(?x)\n(?:\n  (\\bvar\\b)|\n  (?<type-name>\n    (?:\n      (?:\n        (?:(?<identifier>[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n        (?<name-and-type-args> # identifier + type arguments (if any)\n          \\g<identifier>\\s*\n          (?<type-args>\\s*\\[(?:[^\\[\\]]|\\g<type-args>)+\\]\\s*)?\n        )\n        (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?\n        (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n      )\n      (?:\\s*\\*\\s*)* # pointer suffix?\n      (?:\\s*\\?\\s*)? # nullable suffix?\n      (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?\n    )\n  )\n)\\s+\n(\\g<identifier>)\\s+\n\\b(in)\\b",
              "captures": {
                "1": {
                  "name": "keyword.other.var.nemerle"
                },
                "2": {
                  "patterns": [
                    {
                      "include": "#type"
                    }
                  ]
                },
                "7": {
                  "name": "entity.name.variable.local.nemerle"
                },
                "8": {
                  "name": "keyword.control.loop.in.nemerle"
                }
              }
            },
            {
              "match": "(?x) # match foreach (var (x, y) in ...)\n(?:\\b(var)\\b\\s*)?\n(?<tuple>\\((?:[^\\(\\)]|\\g<tuple>)+\\))\\s+\n\\b(in)\\b",
              "captures": {
                "1": {
                  "name": "keyword.other.var.nemerle"
                },
                "2": {
                  "patterns": [
                    {
                      "include": "#tuple-declaration-deconstruction-element-list"
                    }
                  ]
                },
                "3": {
                  "name": "keyword.control.loop.in.nemerle"
                }
              }
            },
            {
              "include": "#expression"
            }
          ]
        },
        {
          "include": "#statement"
        }
      ]
    },
    "try-statement": {
      "patterns": [
        {
          "include": "#try-block"
        },
        {
          "include": "#catch-clause"
        },
        {
          "include": "#finally-clause"
        }
      ]
    },
    "try-block": {
      "begin": "(?<!\\.)\\b(try)\\b",
      "beginCaptures": {
        "1": {
          "name": "keyword.control.try.nemerle"
        }
      },
      "end": "(?<=\\})",
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#block"
        }
      ]
    },
    "finally-clause": {
      "begin": "(?<!\\.)\\b(finally)\\b",
      "beginCaptures": {
        "1": {
          "name": "keyword.control.try.finally.nemerle"
        }
      },
      "end": "(?<=\\})",
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#block"
        }
      ]
    },
    "catch-clause": {
      "begin": "(?<!\\.)\\b(catch)\\b",
      "beginCaptures": {
        "1": {
          "name": "keyword.control.try.catch.nemerle"
        }
      },
      "end": "(?<=\\})",
      "patterns": [
        {
          "begin": "\\(",
          "beginCaptures": {
            "0": {
              "name": "punctuation.parenthesis.open.nemerle"
            }
          },
          "end": "\\)",
          "endCaptures": {
            "0": {
              "name": "punctuation.parenthesis.close.nemerle"
            }
          },
          "patterns": [
            {
              "match": "(?x)\n(?<type-name>\n  (?:\n    (?:\n      (?:(?<identifier>[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n      (?<name-and-type-args> # identifier + type arguments (if any)\n        \\g<identifier>\\s*\n        (?<type-args>\\s*\\[(?:[^\\[\\]]|\\g<type-args>)+\\]\\s*)?\n      )\n      (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?\n      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n    )\n    (?:\\s*\\*\\s*)* # pointer suffix?\n    (?:\\s*\\?\\s*)? # nullable suffix?\n    (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?\n  )\n)\\s*\n(?:\\b(\\g<identifier>)\\b)?",
              "captures": {
                "1": {
                  "patterns": [
                    {
                      "include": "#type"
                    }
                  ]
                },
                "6": {
                  "name": "entity.name.variable.local.nemerle"
                }
              }
            }
          ]
        },
        {
          "include": "#when-clause"
        },
        {
          "include": "#comment"
        },
        {
          "include": "#block"
        }
      ]
    },
    "when-clause": {
      "begin": "(?<!\\.)\\b(when)\\b\\s*(\\()",
      "beginCaptures": {
        "1": {
          "name": "keyword.control.try.when.nemerle"
        },
        "2": {
          "name": "punctuation.parenthesis.open.nemerle"
        }
      },
      "end": "\\)",
      "endCaptures": {
        "0": {
          "name": "punctuation.parenthesis.close.nemerle"
        }
      },
      "patterns": [
        {
          "include": "#expression"
        },
        {
          "include": "#comment"
        }
      ]
    },
    "checked-unchecked-statement": {
      "begin": "(?<!\\.)\\b(?:(checked)|(unchecked))\\b\\s*(?!\\()",
      "beginCaptures": {
        "1": {
          "name": "keyword.other.checked.nemerle"
        },
        "2": {
          "name": "keyword.other.unchecked.nemerle"
        }
      },
      "end": "(?<=\\})",
      "patterns": [
        {
          "include": "#block"
        }
      ]
    },
    "lock-statement": {
      "begin": "(?<!\\.)\\b(lock)\\b\\s*(?=\\()",
      "beginCaptures": {
        "1": {
          "name": "keyword.other.lock.nemerle"
        }
      },
      "end": "(?<=\\})|(?=;)",
      "patterns": [
        {
          "begin": "\\(",
          "beginCaptures": {
            "0": {
              "name": "punctuation.parenthesis.open.nemerle"
            }
          },
          "end": "\\)",
          "endCaptures": {
            "0": {
              "name": "punctuation.parenthesis.close.nemerle"
            }
          },
          "patterns": [
            {
              "include": "#expression"
            }
          ]
        },
        {
          "include": "#statement"
        }
      ]
    },
    "using-statement": {
      "begin": "(?<!\\.)\\b(using)\\b\\s*(?=\\()",
      "beginCaptures": {
        "1": {
          "name": "keyword.other.using.nemerle"
        }
      },
      "end": "(?=\\;|})",
      "patterns": [
        {
          "begin": "\\(",
          "beginCaptures": {
            "0": {
              "name": "punctuation.parenthesis.open.nemerle"
            }
          },
          "end": "\\)",
          "endCaptures": {
            "0": {
              "name": "punctuation.parenthesis.close.nemerle"
            }
          },
          "patterns": [
            {
              "include": "#local-variable-declaration"
            },
            {
              "include": "#expression"
            }
          ]
        },
        {
          "include": "#statement"
        }
      ]
    },
    "labeled-statement": {
      "match": "([_[:alpha:]][_[:alnum:]]*)\\s*(:)",
      "captures": {
        "1": {
          "name": "entity.name.label.nemerle"
        },
        "2": {
          "name": "punctuation.separator.colon.nemerle"
        }
      }
    },
    "local-declaration": {
      "patterns": [
        {
          "include": "#local-constant-declaration"
        },
        {
          "include": "#local-variable-declaration"
        },
        {
          "include": "#local-tuple-var-deconstruction"
        }
      ]
    },
    "local-variable-declaration": {
      "begin": "(?x)\n(?:\n  (?:(\\bref)\\s+)?(\\bvar\\b)| # ref local\n  (?<type-name>\n    (?:\n      (?:ref\\s+)?   # ref local\n      (?:\n        (?:(?<identifier>[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n        (?<name-and-type-args> # identifier + type arguments (if any)\n          \\g<identifier>\\s*\n          (?<type-args>\\s*\\[(?:[^\\[\\]]|\\g<type-args>)+\\]\\s*)?\n        )\n        (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?\n        (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n      )\n      (?:\\s*\\*\\s*)* # pointer suffix?\n      (?:\\s*\\?\\s*)? # nullable suffix?\n      (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?\n    )\n  )\n)\\s+\n(\\g<identifier>)\\s*\n(?=,|;|=|\\))",
      "beginCaptures": {
        "1": {
          "name": "storage.modifier.nemerle"
        },
        "2": {
          "name": "keyword.other.var.nemerle"
        },
        "3": {
          "patterns": [
            {
              "include": "#type"
            }
          ]
        },
        "8": {
          "name": "entity.name.variable.local.nemerle"
        }
      },
      "end": "(?=;|\\))",
      "patterns": [
        {
          "name": "entity.name.variable.local.nemerle",
          "match": "[_[:alpha:]][_[:alnum:]]*"
        },
        {
          "include": "#punctuation-comma"
        },
        {
          "include": "#comment"
        },
        {
          "include": "#variable-initializer"
        }
      ]
    },
    "local-constant-declaration": {
      "begin": "(?x)\n(?<const-keyword>\\b(?:const)\\b)\\s*\n(?<type-name>\n  (?:\n    (?:\n      (?:(?<identifier>[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n      (?<name-and-type-args> # identifier + type arguments (if any)\n        \\g<identifier>\\s*\n        (?<type-args>\\s*\\[(?:[^\\[\\]]|\\g<type-args>)+\\]\\s*)?\n      )\n      (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?\n      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n    )\n    (?:\\s*\\*\\s*)* # pointer suffix?\n    (?:\\s*\\?\\s*)? # nullable suffix?\n    (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?\n  )\n)\\s+\n(\\g<identifier>)\\s*\n(?=,|;|=)",
      "beginCaptures": {
        "1": {
          "name": "storage.modifier.nemerle"
        },
        "2": {
          "patterns": [
            {
              "include": "#type"
            }
          ]
        },
        "7": {
          "name": "entity.name.variable.local.nemerle"
        }
      },
      "end": "(?=;)",
      "patterns": [
        {
          "name": "entity.name.variable.local.nemerle",
          "match": "[_[:alpha:]][_[:alnum:]]*"
        },
        {
          "include": "#punctuation-comma"
        },
        {
          "include": "#comment"
        },
        {
          "include": "#variable-initializer"
        }
      ]
    },
    "local-tuple-var-deconstruction": {
      "begin": "(?x) # e.g. var (x, y) = GetPoint();\n(?:\\b(var)\\b\\s*)\n(?<tuple>\\((?:[^\\(\\)]|\\g<tuple>)+\\))\\s*\n(?=;|=|\\))",
      "beginCaptures": {
        "1": {
          "name": "keyword.other.var.nemerle"
        },
        "2": {
          "patterns": [
            {
              "include": "#tuple-declaration-deconstruction-element-list"
            }
          ]
        }
      },
      "end": "(?=;|\\))",
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#variable-initializer"
        }
      ]
    },
    "tuple-deconstruction-assignment": {
      "match": "(?x)\n(?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\\s*\n(?!=>|==)(?==)",
      "captures": {
        "1": {
          "patterns": [
            {
              "include": "#tuple-deconstruction-element-list"
            }
          ]
        }
      }
    },
    "tuple-declaration-deconstruction-element-list": {
      "begin": "\\(",
      "beginCaptures": {
        "0": {
          "name": "punctuation.parenthesis.open.nemerle"
        }
      },
      "end": "\\)",
      "endCaptures": {
        "0": {
          "name": "punctuation.parenthesis.close.nemerle"
        }
      },
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#tuple-declaration-deconstruction-element-list"
        },
        {
          "include": "#declaration-expression-tuple"
        },
        {
          "include": "#punctuation-comma"
        },
        {
          "match": "(?x) # e.g. x\n\\b([_[:alpha:]][_[:alnum:]]*)\\b\\s*\n(?=[,)])",
          "captures": {
            "1": {
              "name": "entity.name.variable.tuple-element.nemerle"
            }
          }
        }
      ]
    },
    "tuple-deconstruction-element-list": {
      "begin": "\\(",
      "beginCaptures": {
        "0": {
          "name": "punctuation.parenthesis.open.nemerle"
        }
      },
      "end": "\\)",
      "endCaptures": {
        "0": {
          "name": "punctuation.parenthesis.close.nemerle"
        }
      },
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#tuple-deconstruction-element-list"
        },
        {
          "include": "#declaration-expression-tuple"
        },
        {
          "include": "#punctuation-comma"
        },
        {
          "match": "(?x) # e.g. x\n\\b([_[:alpha:]][_[:alnum:]]*)\\b\\s*\n(?=[,)])",
          "captures": {
            "1": {
              "name": "variable.other.readwrite.nemerle"
            }
          }
        }
      ]
    },
    "declaration-expression-local": {
      "match": "(?x) # e.g. int x OR var x\n(?:\n  \\b(var)\\b|\n  (?<type-name>\n    (?:\n      (?:\n        (?:(?<identifier>[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n        (?<name-and-type-args> # identifier + type arguments (if any)\n          \\g<identifier>\\s*\n          (?<type-args>\\s*\\[(?:[^\\[\\]]|\\g<type-args>)+\\]\\s*)?\n        )\n        (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?\n        (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n      )\n      (?:\\s*\\*\\s*)* # pointer suffix?\n      (?:\\s*\\?\\s*)? # nullable suffix?\n      (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?\n    )\n  )\n)\\s+\n\\b(\\g<identifier>)\\b\\s*\n(?=[,)\\]])",
      "captures": {
        "1": {
          "name": "keyword.other.var.nemerle"
        },
        "2": {
          "patterns": [
            {
              "include": "#type"
            }
          ]
        },
        "7": {
          "name": "entity.name.variable.local.nemerle"
        }
      }
    },
    "declaration-expression-tuple": {
      "match": "(?x) # e.g. int x OR var x\n(?:\n  \\b(var)\\b|\n  (?<type-name>\n    (?:\n      (?:\n        (?:(?<identifier>[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n        (?<name-and-type-args> # identifier + type arguments (if any)\n          \\g<identifier>\\s*\n          (?<type-args>\\s*\\[(?:[^\\[\\]]|\\g<type-args>)+\\]\\s*)?\n        )\n        (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?\n        (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n      )\n      (?:\\s*\\*\\s*)* # pointer suffix?\n      (?:\\s*\\?\\s*)? # nullable suffix?\n      (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?\n    )\n  )\n)\\s+\n\\b(\\g<identifier>)\\b\\s*\n(?=[,)])",
      "captures": {
        "1": {
          "name": "keyword.other.var.nemerle"
        },
        "2": {
          "patterns": [
            {
              "include": "#type"
            }
          ]
        },
        "7": {
          "name": "entity.name.variable.tuple-element.nemerle"
        }
      }
    },
    "checked-unchecked-expression": {
      "begin": "(?<!\\.)\\b(?:(checked)|(unchecked))\\b\\s*(\\()",
      "beginCaptures": {
        "1": {
          "name": "keyword.other.checked.nemerle"
        },
        "2": {
          "name": "keyword.other.unchecked.nemerle"
        },
        "3": {
          "name": "punctuation.parenthesis.open.nemerle"
        }
      },
      "end": "\\)",
      "endCaptures": {
        "0": {
          "name": "punctuation.parenthesis.close.nemerle"
        }
      },
      "patterns": [
        {
          "include": "#expression"
        }
      ]
    },
    "typeof-or-default-expression": {
      "begin": "(?<!\\.)\\b(?:(typeof)|(default))\\b\\s*(\\()",
      "beginCaptures": {
        "1": {
          "name": "keyword.other.typeof.nemerle"
        },
        "2": {
          "name": "keyword.other.default.nemerle"
        },
        "3": {
          "name": "punctuation.parenthesis.open.nemerle"
        }
      },
      "end": "\\)",
      "endCaptures": {
        "0": {
          "name": "punctuation.parenthesis.close.nemerle"
        }
      },
      "patterns": [
        {
          "include": "#type"
        }
      ]
    },
    "nameof-expression": {
      "begin": "(?<!\\.)\\b(nameof)\\b\\s*(\\()",
      "beginCaptures": {
        "1": {
          "name": "keyword.other.nameof.nemerle"
        },
        "2": {
          "name": "punctuation.parenthesis.open.nemerle"
        }
      },
      "end": "\\)",
      "endCaptures": {
        "0": {
          "name": "punctuation.parenthesis.close.nemerle"
        }
      },
      "patterns": [
        {
          "include": "#expression"
        }
      ]
    },
    "throw-expression": {
      "begin": "(?<!\\.)\\b(throw)\\b",
      "beginCaptures": {
        "1": {
          "name": "keyword.control.flow.throw.nemerle"
        }
      },
      "end": "(?=;)",
      "patterns": [
        {
          "include": "#expression"
        }
      ]
    },
    "interpolated-string": {
      "name": "string.quoted.double.nemerle",
      "begin": "\\$\"",
      "beginCaptures": {
        "0": {
          "name": "punctuation.definition.string.begin.nemerle"
        }
      },
      "end": "(\")|((?:[^\\\\\\n])$)",
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.string.end.nemerle"
        },
        "2": {
          "name": "invalid.illegal.newline.nemerle"
        }
      },
      "patterns": [
        {
          "include": "#string-character-escape"
        },
        {
          "include": "#interpolation"
        }
      ]
    },
    "verbatim-interpolated-string": {
      "name": "string.quoted.double.nemerle",
      "begin": "\\$@\"",
      "beginCaptures": {
        "0": {
          "name": "punctuation.definition.string.begin.nemerle"
        }
      },
      "end": "\"(?=[^\"])",
      "endCaptures": {
        "0": {
          "name": "punctuation.definition.string.end.nemerle"
        }
      },
      "patterns": [
        {
          "include": "#verbatim-string-character-escape"
        },
        {
          "include": "#interpolation"
        }
      ]
    },
    "interpolation": {
      "name": "meta.interpolation.nemerle",
      "begin": "(?<=[^\\{])((?:\\{\\{)*)(\\{)(?=[^\\{])",
      "beginCaptures": {
        "1": {
          "name": "string.quoted.double.nemerle"
        },
        "2": {
          "name": "punctuation.definition.interpolation.begin.nemerle"
        }
      },
      "end": "\\}",
      "endCaptures": {
        "0": {
          "name": "punctuation.definition.interpolation.end.nemerle"
        }
      },
      "patterns": [
        {
          "include": "#expression"
        }
      ]
    },
    "literal": {
      "patterns": [
        {
          "include": "#boolean-literal"
        },
        {
          "include": "#null-literal"
        },
        {
          "include": "#numeric-literal"
        },
        {
          "include": "#char-literal"
        },
        {
          "include": "#string-literal"
        },
        {
          "include": "#verbatim-string-literal"
        },
        {
          "include": "#tuple-literal"
        }
      ]
    },
    "boolean-literal": {
      "patterns": [
        {
          "name": "constant.language.boolean.true.nemerle",
          "match": "(?<!\\.)\\btrue\\b"
        },
        {
          "name": "constant.language.boolean.false.nemerle",
          "match": "(?<!\\.)\\bfalse\\b"
        }
      ]
    },
    "null-literal": {
      "name": "constant.language.null.nemerle",
      "match": "(?<!\\.)\\bnull\\b"
    },
    "numeric-literal": {
      "patterns": [
        {
          "name": "constant.numeric.hex.nemerle",
          "match": "\\b0(x|X)[0-9a-fA-F_]+(U|u|L|l|UL|Ul|uL|ul|LU|Lu|lU|lu)?\\b"
        },
        {
          "name": "constant.numeric.binary.nemerle",
          "match": "\\b0(b|B)[01_]+(U|u|L|l|UL|Ul|uL|ul|LU|Lu|lU|lu)?\\b"
        },
        {
          "name": "constant.numeric.decimal.nemerle",
          "match": "\\b([0-9_]+)?\\.[0-9_]+((e|E)[0-9]+)?(F|f|D|d|M|m)?\\b"
        },
        {
          "name": "constant.numeric.decimal.nemerle",
          "match": "\\b[0-9_]+(e|E)[0-9_]+(F|f|D|d|M|m)?\\b"
        },
        {
          "name": "constant.numeric.decimal.nemerle",
          "match": "\\b[0-9_]+(F|f|D|d|M|m)\\b"
        },
        {
          "name": "constant.numeric.decimal.nemerle",
          "match": "\\b[0-9_]+(U|u|L|l|UL|Ul|uL|ul|LU|Lu|lU|lu)?\\b"
        }
      ]
    },
    "char-literal": {
      "name": "string.quoted.single.nemerle",
      "begin": "'",
      "beginCaptures": {
        "0": {
          "name": "punctuation.definition.char.begin.nemerle"
        }
      },
      "end": "(\\')|((?:[^\\\\\\n])$)",
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.char.end.nemerle"
        },
        "2": {
          "name": "invalid.illegal.newline.nemerle"
        }
      },
      "patterns": [
        {
          "include": "#string-character-escape"
        }
      ]
    },
    "string-literal": {
      "name": "string.quoted.double.nemerle",
      "begin": "(?<!@)\"",
      "beginCaptures": {
        "0": {
          "name": "punctuation.definition.string.begin.nemerle"
        }
      },
      "end": "(\")|((?:[^\\\\\\n])$)",
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.string.end.nemerle"
        },
        "2": {
          "name": "invalid.illegal.newline.nemerle"
        }
      },
      "patterns": [
        {
          "include": "#string-character-escape"
        }
      ]
    },
    "string-character-escape": {
      "name": "constant.character.escape.nemerle",
      "match": "\\\\."
    },
    "verbatim-string-literal": {
      "name": "string.quoted.double.nemerle",
      "begin": "@\"",
      "beginCaptures": {
        "0": {
          "name": "punctuation.definition.string.begin.nemerle"
        }
      },
      "end": "\"(?=[^\"])",
      "endCaptures": {
        "0": {
          "name": "punctuation.definition.string.end.nemerle"
        }
      },
      "patterns": [
        {
          "include": "#verbatim-string-character-escape"
        }
      ]
    },
    "verbatim-string-character-escape": {
      "name": "constant.character.escape.nemerle",
      "match": "\"\""
    },
    "tuple-literal": {
      "begin": "(\\()(?=.*[:,])",
      "beginCaptures": {
        "1": {
          "name": "punctuation.parenthesis.open.nemerle"
        }
      },
      "end": "\\)",
      "endCaptures": {
        "0": {
          "name": "punctuation.parenthesis.close.nemerle"
        }
      },
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#tuple-literal-element"
        },
        {
          "include": "#punctuation-comma"
        }
      ]
    },
    "tuple-literal-element": {
      "begin": "(?x)\n(?:([_[:alpha:]][_[:alnum:]]*)\\s*(:)\\s*)?\n(?![,)])",
      "beginCaptures": {
        "0": {
          "name": "entity.name.variable.tuple-element.nemerle"
        },
        "1": {
          "name": "punctuation.separator.colon.nemerle"
        }
      },
      "end": "(?=[,)])",
      "patterns": [
        {
          "include": "#expression"
        }
      ]
    },
    "expression-operators": {
      "patterns": [
        {
          "name": "keyword.operator.assignment.compound.nemerle",
          "match": "\\*=|/=|%=|\\+=|-="
        },
        {
          "name": "keyword.operator.assignment.compound.bitwise.nemerle",
          "match": "\\&=|\\^=|<<=|>>=|\\|="
        },
        {
          "name": "keyword.operator.bitwise.shift.nemerle",
          "match": "<<|>>"
        },
        {
          "name": "keyword.operator.comparison.nemerle",
          "match": "==|!="
        },
        {
          "name": "keyword.operator.relational.nemerle",
          "match": "<=|>=|<|>"
        },
        {
          "name": "keyword.operator.logical.nemerle",
          "match": "\\!|&&|\\|\\|"
        },
        {
          "name": "keyword.operator.bitwise.nemerle",
          "match": "\\&|~|\\^|\\|"
        },
        {
          "name": "keyword.operator.assignment.nemerle",
          "match": "\\="
        },
        {
          "name": "keyword.operator.decrement.nemerle",
          "match": "--"
        },
        {
          "name": "keyword.operator.increment.nemerle",
          "match": "\\+\\+"
        },
        {
          "name": "keyword.operator.arithmetic.nemerle",
          "match": "%|\\*|/|-|\\+"
        },
        {
          "name": "keyword.operator.null-coalescing.nemerle",
          "match": "\\?\\?"
        }
      ]
    },
    "conditional-operator": {
      "begin": "(?<!\\?)\\?(?!\\?|\\.|\\[)",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.conditional.question-mark.nemerle"
        }
      },
      "end": ":",
      "endCaptures": {
        "0": {
          "name": "keyword.operator.conditional.colon.nemerle"
        }
      },
      "patterns": [
        {
          "include": "#expression"
        }
      ]
    },
    "await-expression": {
      "name": "keyword.other.await.nemerle",
      "match": "(?!\\.)\\b(await)\\b"
    },
    "parenthesized-expression": {
      "begin": "\\(",
      "beginCaptures": {
        "0": {
          "name": "punctuation.parenthesis.open.nemerle"
        }
      },
      "end": "\\)",
      "endCaptures": {
        "0": {
          "name": "punctuation.parenthesis.close.nemerle"
        }
      },
      "patterns": [
        {
          "include": "#expression"
        }
      ]
    },
    "initializer-expression": {
      "begin": "\\{",
      "beginCaptures": {
        "0": {
          "name": "punctuation.curlybrace.open.nemerle"
        }
      },
      "end": "\\}",
      "endCaptures": {
        "0": {
          "name": "punctuation.curlybrace.close.nemerle"
        }
      },
      "patterns": [
        {
          "include": "#expression"
        },
        {
          "include": "#punctuation-comma"
        }
      ]
    },
    "identifier": {
      "name": "variable.other.readwrite.nemerle",
      "match": "[_[:alpha:]][_[:alnum:]]*"
    },
    "cast-expression": {
      "match": "(?x)\n(\\()\\s*\n(?<type-name>\n  (?:\n    (?:\n      (?:(?<identifier>[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n      (?<name-and-type-args> # identifier + type arguments (if any)\n        \\g<identifier>\\s*\n        (?<type-args>\\s*\\[(?:[^\\[\\]]|\\g<type-args>)+\\]\\s*)?\n      )\n      (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?\n      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n    )\n    (?:\\s*\\*\\s*)* # pointer suffix?\n    (?:\\s*\\?\\s*)? # nullable suffix?\n    (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?\n  )\n)\\s*\n(\\))(?=\\s*[_[:alnum:]\\(])",
      "captures": {
        "1": {
          "name": "punctuation.parenthesis.open.nemerle"
        },
        "2": {
          "patterns": [
            {
              "include": "#type"
            }
          ]
        },
        "7": {
          "name": "punctuation.parenthesis.close.nemerle"
        }
      }
    },
    "as-expression": {
      "match": "(?x)\n(?<!\\.)\\b(as)\\b\\s*\n(?<type-name>\n  (?:\n    (?:\n      (?:(?<identifier>[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n      (?<name-and-type-args> # identifier + type arguments (if any)\n        \\g<identifier>\\s*\n        (?<type-args>\\s*\\[(?:[^\\[\\]]|\\g<type-args>)+\\]\\s*)?\n      )\n      (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?\n      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n    )\n    (?:\\s*\\*\\s*)* # pointer suffix?\n    (?:\\s*\\?\\s*)? # nullable suffix?\n    (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?\n  )\n)?",
      "captures": {
        "1": {
          "name": "keyword.other.as.nemerle"
        },
        "2": {
          "patterns": [
            {
              "include": "#type"
            }
          ]
        }
      }
    },
    "is-expression": {
      "match": "(?x)\n(?<!\\.)\\b(is)\\b\\s*\n(?<type-name>\n  (?:\n    (?:\n      (?:(?<identifier>[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n      (?<name-and-type-args> # identifier + type arguments (if any)\n        \\g<identifier>\\s*\n        (?<type-args>\\s*\\[(?:[^\\[\\]]|\\g<type-args>)+\\]\\s*)?\n      )\n      (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?\n      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n    )\n    (?:\\s*\\*\\s*)* # pointer suffix?\n    (?:\\s*\\?\\s*)? # nullable suffix?\n    (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?\n  )\n)?",
      "captures": {
        "1": {
          "name": "keyword.other.is.nemerle"
        },
        "2": {
          "patterns": [
            {
              "include": "#type"
            }
          ]
        }
      }
    },
    "this-or-base-expression": {
      "match": "\\b(?:(base)|(this))\\b",
      "captures": {
        "1": {
          "name": "keyword.other.base.nemerle"
        },
        "2": {
          "name": "keyword.other.this.nemerle"
        }
      }
    },
    "invocation-expression": {
      "begin": "(?x)\n(?:(\\?)\\s*)?                                     # preceding null-conditional operator?\n(?:(\\.)\\s*)?                                     # preceding dot?\n([_[:alpha:]][_[:alnum:]]*)\\s*                   # method name\n(?<type-args>\\s*\\[([^\\[\\]]|\\g<type-args>)+\\]\\s*)?\\s* # type arguments\n(?=\\()                                           # open paren of argument list",
      "beginCaptures": {
        "1": {
          "name": "keyword.operator.null-conditional.nemerle"
        },
        "2": {
          "name": "punctuation.accessor.nemerle"
        },
        "3": {
          "name": "entity.name.function.nemerle"
        },
        "4": {
          "patterns": [
            {
              "include": "#type-arguments"
            }
          ]
        }
      },
      "end": "(?<=\\))",
      "patterns": [
        {
          "include": "#argument-list"
        }
      ]
    },
    "element-access-expression": {
      "begin": "(?x)\n(?:(\\?)\\s*)?                        # preceding null-conditional operator?\n(?:(\\.)\\s*)?                        # preceding dot?\n(?:([_[:alpha:]][_[:alnum:]]*)\\s*)? # property name\n(?:(\\?)\\s*)?                        # null-conditional operator?\n(?=\\[)                              # open bracket of argument list",
      "beginCaptures": {
        "1": {
          "name": "keyword.operator.null-conditional.nemerle"
        },
        "2": {
          "name": "punctuation.accessor.nemerle"
        },
        "3": {
          "name": "variable.other.object.property.nemerle"
        },
        "4": {
          "name": "keyword.operator.null-conditional.nemerle"
        }
      },
      "end": "(?<=\\])(?!\\s*\\[)",
      "patterns": [
        {
          "include": "#bracketed-argument-list"
        }
      ]
    },
    "member-access-expression": {
      "patterns": [
        {
          "match": "(?x)\n(?:(\\?)\\s*)?                   # preceding null-conditional operator?\n(\\.)\\s*                        # preceding dot\n([_[:alpha:]][_[:alnum:]]*)\\s* # property name\n(?![_[:alnum:]]|\\(|(\\?)?\\[|<)  # next character is not alpha-numeric, nor a (, [, or <. Also, test for ?[",
          "captures": {
            "1": {
              "name": "keyword.operator.null-conditional.nemerle"
            },
            "2": {
              "name": "punctuation.accessor.nemerle"
            },
            "3": {
              "name": "variable.other.object.property.nemerle"
            }
          }
        },
        {
          "match": "(?x)\n(\\.)?\\s*\n([_[:alpha:]][_[:alnum:]]*)\n(?<type-params>\\s*\\[([^\\[\\]]|\\g<type-params>)+\\]\\s*)\n(?=\n  (\\s*\\?)?\n  \\s*\\.\\s*[_[:alpha:]][_[:alnum:]]*\n)",
          "captures": {
            "1": {
              "name": "punctuation.accessor.nemerle"
            },
            "2": {
              "name": "variable.other.object.nemerle"
            },
            "3": {
              "patterns": [
                {
                  "include": "#type-arguments"
                }
              ]
            }
          }
        },
        {
          "match": "(?x)\n([_[:alpha:]][_[:alnum:]]*)\n(?=\n  (\\s*\\?)?\n  \\s*\\.\\s*[_[:alpha:]][_[:alnum:]]*\n)",
          "captures": {
            "1": {
              "name": "variable.other.object.nemerle"
            }
          }
        }
      ]
    },
    "object-creation-expression": {
      "patterns": [
        {
          "include": "#object-creation-expression-with-parameters"
        },
        {
          "include": "#object-creation-expression-with-no-parameters"
        }
      ]
    },
    "object-creation-expression-with-parameters": {
      "begin": "(?x)\n(new)\\s+\n(?<type-name>\n  (?:\n    (?:\n      (?:(?<identifier>[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n      (?<name-and-type-args> # identifier + type arguments (if any)\n        \\g<identifier>\\s*\n        (?<type-args>\\s*\\[(?:[^\\[\\]]|\\g<type-args>)+\\]\\s*)?\n      )\n      (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?\n      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n    )\n    (?:\\s*\\*\\s*)* # pointer suffix?\n    (?:\\s*\\?\\s*)? # nullable suffix?\n    (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?\n  )\n)\\s*\n(?=\\()",
      "beginCaptures": {
        "1": {
          "name": "keyword.other.new.nemerle"
        },
        "2": {
          "patterns": [
            {
              "include": "#type"
            }
          ]
        }
      },
      "end": "(?<=\\))",
      "patterns": [
        {
          "include": "#argument-list"
        }
      ]
    },
    "object-creation-expression-with-no-parameters": {
      "match": "(?x)\n(new)\\s+\n(?<type-name>\n  (?:\n    (?:\n      (?:(?<identifier>[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n      (?<name-and-type-args> # identifier + type arguments (if any)\n        \\g<identifier>\\s*\n        (?<type-args>\\s*\\[(?:[^\\[\\]]|\\g<type-args>)+\\]\\s*)?\n      )\n      (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?\n      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n    )\n    (?:\\s*\\*\\s*)* # pointer suffix?\n    (?:\\s*\\?\\s*)? # nullable suffix?\n    (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?\n  )\n)\\s*\n(?=\\{|$)",
      "captures": {
        "1": {
          "name": "keyword.other.new.nemerle"
        },
        "2": {
          "patterns": [
            {
              "include": "#type"
            }
          ]
        }
      }
    },
    "array-creation-expression": {
      "begin": "(?x)\n\\b(new)\\b\\s*\n(?<type-name>\n  (?:\n    (?:\n      (?:(?<identifier>[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n      (?<name-and-type-args> # identifier + type arguments (if any)\n        \\g<identifier>\\s*\n        (?<type-args>\\s*\\[(?:[^\\[\\]]|\\g<type-args>)+\\]\\s*)?\n      )\n      (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?\n      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n    )\n    (?:\\s*\\*\\s*)* # pointer suffix?\n    (?:\\s*\\?\\s*)? # nullable suffix?\n    (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?\n  )\n)?\\s*\n(?=\\[)",
      "beginCaptures": {
        "1": {
          "name": "keyword.other.new.nemerle"
        },
        "2": {
          "patterns": [
            {
              "include": "#type"
            }
          ]
        }
      },
      "end": "(?<=\\])",
      "patterns": [
        {
          "include": "#bracketed-argument-list"
        }
      ]
    },
    "anonymous-object-creation-expression": {
      "begin": "\\b(new)\\b\\s*(?=\\{|$)",
      "beginCaptures": {
        "1": {
          "name": "keyword.other.new.nemerle"
        }
      },
      "end": "(?=\\)|;|})",
      "patterns": [
        {
          "include": "#initializer-expression"
        }
      ]
    },
    "bracketed-parameter-list": {
      "begin": "(?=(\\[))",
      "beginCaptures": {
        "1": {
          "name": "punctuation.squarebracket.open.nemerle"
        }
      },
      "end": "(?=(\\]))",
      "endCaptures": {
        "1": {
          "name": "punctuation.squarebracket.close.nemerle"
        }
      },
      "patterns": [
        {
          "begin": "(?<=\\[)",
          "end": "(?=\\])",
          "patterns": [
            {
              "include": "#comment"
            },
            {
              "include": "#attribute-section"
            },
            {
              "name": "storage.modifier.nemerle",
              "match": "\\b(ref|params|out)\\b"
            },
            {
              "match": "\\s+([_[:alpha:]][_[:alnum:]]*)\\s*(?=[=,\\]])",
              "captures": {
                "1": {
                  "name": "entity.name.variable.parameter.nemerle"
                }
              }
            },
            {
              "include": "#variable-initializer"
            },
            {
              "include": "#type"
            },
            {
              "include": "#punctuation-comma"
            }
          ]
        }
      ]
    },
    "parenthesized-parameter-list": {
      "begin": "(\\()",
      "beginCaptures": {
        "0": {
          "name": "punctuation.parenthesis.open.nemerle"
        }
      },
      "end": "(\\))",
      "endCaptures": {
        "0": {
          "name": "punctuation.parenthesis.close.nemerle"
        }
      },
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#attribute-section"
        },
        {
          "name": "storage.modifier.nemerle",
          "match": "\\b(ref|params|out|this)\\b"
        },
        {
          "match": "\\b([_[:alpha:]][_[:alnum:]]*)\\s*(?=[=,)])",
          "captures": {
            "1": {
              "name": "entity.name.variable.parameter.nemerle"
            }
          }
        },
        {
          "include": "#variable-initializer"
        },
        {
          "include": "#type"
        },
        {
          "include": "#punctuation-comma"
        }
      ]
    },
    "argument-list": {
      "begin": "\\(",
      "beginCaptures": {
        "0": {
          "name": "punctuation.parenthesis.open.nemerle"
        }
      },
      "end": "\\)",
      "endCaptures": {
        "0": {
          "name": "punctuation.parenthesis.close.nemerle"
        }
      },
      "patterns": [
        {
          "include": "#named-argument"
        },
        {
          "include": "#argument"
        },
        {
          "include": "#punctuation-comma"
        }
      ]
    },
    "bracketed-argument-list": {
      "begin": "\\[",
      "beginCaptures": {
        "0": {
          "name": "punctuation.squarebracket.open.nemerle"
        }
      },
      "end": "\\]",
      "endCaptures": {
        "0": {
          "name": "punctuation.squarebracket.close.nemerle"
        }
      },
      "patterns": [
        {
          "include": "#named-argument"
        },
        {
          "include": "#argument"
        },
        {
          "include": "#punctuation-comma"
        }
      ]
    },
    "named-argument": {
      "begin": "([_[:alpha:]][_[:alnum:]]*)\\s*(:)",
      "beginCaptures": {
        "1": {
          "name": "entity.name.variable.parameter.nemerle"
        },
        "2": {
          "name": "punctuation.separator.colon.nemerle"
        }
      },
      "end": "(?=(,|\\)|\\]))",
      "patterns": [
        {
          "include": "#argument"
        }
      ]
    },
    "argument": {
      "patterns": [
        {
          "name": "storage.modifier.nemerle",
          "match": "\\b(ref|out)\\b"
        },
        {
          "include": "#declaration-expression-local"
        },
        {
          "include": "#expression"
        }
      ]
    },
    "query-expression": {
      "begin": "(?x)\n\\b(from)\\b\\s*\n(?<type-name>\n  (?:\n    (?:\n      (?:(?<identifier>[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n      (?<name-and-type-args> # identifier + type arguments (if any)\n        \\g<identifier>\\s*\n        (?<type-args>\\s*\\[(?:[^\\[\\]]|\\g<type-args>)+\\]\\s*)?\n      )\n      (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?\n      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n    )\n    (?:\\s*\\*\\s*)* # pointer suffix?\n    (?:\\s*\\?\\s*)? # nullable suffix?\n    (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?\n  )\n)?\n\\b(\\g<identifier>)\\b\\s*\n\\b(in)\\b\\s*",
      "beginCaptures": {
        "1": {
          "name": "keyword.query.from.nemerle"
        },
        "2": {
          "patterns": [
            {
              "include": "#type"
            }
          ]
        },
        "7": {
          "name": "entity.name.variable.range-variable.nemerle"
        },
        "8": {
          "name": "keyword.query.in.nemerle"
        }
      },
      "end": "(?=;|\\))",
      "patterns": [
        {
          "include": "#query-body"
        },
        {
          "include": "#expression"
        }
      ]
    },
    "query-body": {
      "patterns": [
        {
          "include": "#let-clause"
        },
        {
          "include": "#where-clause"
        },
        {
          "include": "#join-clause"
        },
        {
          "include": "#orderby-clause"
        },
        {
          "include": "#select-clause"
        },
        {
          "include": "#group-clause"
        }
      ]
    },
    "let-clause": {
      "begin": "(?x)\n\\b(let)\\b\\s*\n\\b([_[:alpha:]][_[:alnum:]]*)\\b\\s*\n(=)\\s*",
      "beginCaptures": {
        "1": {
          "name": "keyword.query.let.nemerle"
        },
        "2": {
          "name": "entity.name.variable.range-variable.nemerle"
        },
        "3": {
          "name": "keyword.operator.assignment.nemerle"
        }
      },
      "end": "(?=;|\\))",
      "patterns": [
        {
          "include": "#query-body"
        },
        {
          "include": "#expression"
        }
      ]
    },
    "where-clause": {
      "begin": "(?x)\n\\b(where)\\b\\s*",
      "beginCaptures": {
        "1": {
          "name": "keyword.query.where.nemerle"
        }
      },
      "end": "(?=;|\\))",
      "patterns": [
        {
          "include": "#query-body"
        },
        {
          "include": "#expression"
        }
      ]
    },
    "join-clause": {
      "begin": "(?x)\n\\b(join)\\b\\s*\n(?<type-name>\n  (?:\n    (?:\n      (?:(?<identifier>[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n      (?<name-and-type-args> # identifier + type arguments (if any)\n        \\g<identifier>\\s*\n        (?<type-args>\\s*\\[(?:[^\\[\\]]|\\g<type-args>)+\\]\\s*)?\n      )\n      (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?\n      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n    )\n    (?:\\s*\\*\\s*)* # pointer suffix?\n    (?:\\s*\\?\\s*)? # nullable suffix?\n    (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?\n  )\n)?\n\\b(\\g<identifier>)\\b\\s*\n\\b(in)\\b\\s*",
      "beginCaptures": {
        "1": {
          "name": "keyword.query.join.nemerle"
        },
        "2": {
          "patterns": [
            {
              "include": "#type"
            }
          ]
        },
        "7": {
          "name": "entity.name.variable.range-variable.nemerle"
        },
        "8": {
          "name": "keyword.query.in.nemerle"
        }
      },
      "end": "(?=;|\\))",
      "patterns": [
        {
          "include": "#join-on"
        },
        {
          "include": "#join-equals"
        },
        {
          "include": "#join-into"
        },
        {
          "include": "#query-body"
        },
        {
          "include": "#expression"
        }
      ]
    },
    "join-on": {
      "match": "\\b(on)\\b\\s*",
      "captures": {
        "1": {
          "name": "keyword.query.on.nemerle"
        }
      }
    },
    "join-equals": {
      "match": "\\b(equals)\\b\\s*",
      "captures": {
        "1": {
          "name": "keyword.query.equals.nemerle"
        }
      }
    },
    "join-into": {
      "match": "(?x)\n\\b(into)\\b\\s*\n\\b([_[:alpha:]][_[:alnum:]]*)\\b\\s*",
      "captures": {
        "1": {
          "name": "keyword.query.into.nemerle"
        },
        "2": {
          "name": "entity.name.variable.range-variable.nemerle"
        }
      }
    },
    "orderby-clause": {
      "begin": "\\b(orderby)\\b\\s*",
      "beginCaptures": {
        "1": {
          "name": "keyword.query.orderby.nemerle"
        }
      },
      "end": "(?=;|\\))",
      "patterns": [
        {
          "include": "#ordering-direction"
        },
        {
          "include": "#query-body"
        },
        {
          "include": "#expression"
        },
        {
          "include": "#punctuation-comma"
        }
      ]
    },
    "ordering-direction": {
      "match": "\\b(?:(ascending)|(descending))\\b",
      "captures": {
        "1": {
          "name": "keyword.query.ascending.nemerle"
        },
        "2": {
          "name": "keyword.query.descending.nemerle"
        }
      }
    },
    "select-clause": {
      "begin": "\\b(select)\\b\\s*",
      "beginCaptures": {
        "1": {
          "name": "keyword.query.select.nemerle"
        }
      },
      "end": "(?=;|\\))",
      "patterns": [
        {
          "include": "#query-body"
        },
        {
          "include": "#expression"
        }
      ]
    },
    "group-clause": {
      "begin": "\\b(group)\\b\\s*",
      "beginCaptures": {
        "1": {
          "name": "keyword.query.group.nemerle"
        }
      },
      "end": "(?=;|\\))",
      "patterns": [
        {
          "include": "#group-by"
        },
        {
          "include": "#group-into"
        },
        {
          "include": "#query-body"
        },
        {
          "include": "#expression"
        }
      ]
    },
    "group-by": {
      "match": "\\b(by)\\b\\s*",
      "captures": {
        "1": {
          "name": "keyword.query.by.nemerle"
        }
      }
    },
    "group-into": {
      "match": "(?x)\n\\b(into)\\b\\s*\n\\b([_[:alpha:]][_[:alnum:]]*)\\b\\s*",
      "captures": {
        "1": {
          "name": "keyword.query.into.nemerle"
        },
        "2": {
          "name": "entity.name.variable.range-variable.nemerle"
        }
      }
    },
    "anonymous-method-expression": {
      "patterns": [
        {
          "begin": "(?x)\n(?:\\b(async)\\b\\s*)?\n\\b([_[:alpha:]][_[:alnum:]]*)\\b\\s*\n(=>)",
          "beginCaptures": {
            "1": {
              "name": "storage.modifier.nemerle"
            },
            "2": {
              "name": "entity.name.variable.parameter.nemerle"
            },
            "3": {
              "name": "keyword.operator.arrow.nemerle"
            }
          },
          "end": "(?=\\)|;|}|,)",
          "patterns": [
            {
              "include": "#block"
            },
            {
              "include": "#ref-modifier"
            },
            {
              "include": "#expression"
            }
          ]
        },
        {
          "begin": "(?x)\n(?:\\b(async)\\b\\s*)?\n(\\(.*?\\))\\s*\n(=>)",
          "beginCaptures": {
            "1": {
              "name": "storage.modifier.nemerle"
            },
            "2": {
              "patterns": [
                {
                  "include": "#lambda-parameter-list"
                }
              ]
            },
            "3": {
              "name": "keyword.operator.arrow.nemerle"
            }
          },
          "end": "(?=\\)|;|}|,)",
          "patterns": [
            {
              "include": "#block"
            },
            {
              "include": "#ref-modifier"
            },
            {
              "include": "#expression"
            }
          ]
        },
        {
          "begin": "(?x)\n(?:\\b(async)\\b\\s*)?\n(?:\\b(delegate)\\b\\s*)",
          "beginCaptures": {
            "1": {
              "name": "storage.modifier.nemerle"
            },
            "2": {
              "name": "keyword.other.delegate.nemerle"
            }
          },
          "end": "(?=\\)|;|}|,)",
          "patterns": [
            {
              "include": "#parenthesized-parameter-list"
            },
            {
              "include": "#block"
            },
            {
              "include": "#expression"
            }
          ]
        }
      ]
    },
    "lambda-parameter-list": {
      "begin": "\\(",
      "beginCaptures": {
        "0": {
          "name": "punctuation.parenthesis.open.nemerle"
        }
      },
      "end": "\\)",
      "endCaptures": {
        "0": {
          "name": "punctuation.parenthesis.close.nemerle"
        }
      },
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#attribute-section"
        },
        {
          "include": "#lambda-parameter"
        },
        {
          "include": "#punctuation-comma"
        }
      ]
    },
    "lambda-parameter": {
      "match": "(?x)\n(ref|out)?\\s*\n(?<type-name>\n  (?:\n    (?:\n      (?:(?<identifier>[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n      (?<name-and-type-args> # identifier + type arguments (if any)\n        \\g<identifier>\\s*\n        (?<type-args>\\s*\\[(?:[^\\[\\]]|\\g<type-args>)+\\]\\s*)?\n      )\n      (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?\n      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n    )\n    (?:\\s*\\*\\s*)* # pointer suffix?\n    (?:\\s*\\?\\s*)? # nullable suffix?\n    (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?\n  )\n)?\n\\b(\\g<identifier>)\\b\\s*\n(?=[,)])",
      "captures": {
        "1": {
          "name": "storage.modifier.nemerle"
        },
        "2": {
          "patterns": [
            {
              "include": "#type"
            }
          ]
        },
        "7": {
          "name": "entity.name.variable.parameter.nemerle"
        }
      }
    },
    "type": {
      "name": "meta.type.nemerle",
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#ref-modifier"
        },
        {
          "include": "#tuple-type"
        },
        {
          "include": "#type-builtin"
        },
        {
          "include": "#type-name"
        },
        {
          "include": "#type-arguments"
        },
        {
          "include": "#type-array-suffix"
        },
        {
          "include": "#type-nullable-suffix"
        }
      ]
    },
    "ref-modifier": {
      "name": "storage.modifier.nemerle",
      "match": "ref"
    },
    "tuple-type": {
      "begin": "\\(",
      "beginCaptures": {
        "0": {
          "name": "punctuation.parenthesis.open.nemerle"
        }
      },
      "end": "\\)",
      "endCaptures": {
        "0": {
          "name": "punctuation.parenthesis.close.nemerle"
        }
      },
      "patterns": [
        {
          "include": "#tuple-element"
        },
        {
          "include": "#punctuation-comma"
        }
      ]
    },
    "tuple-element": {
      "match": "(?x)\n(?<type-name>\n  (?:\n    (?:\n      (?:(?<identifier>[_[:alpha:]][_[:alnum:]]*)\\s*\\:\\:\\s*)? # alias-qualification\n      (?<name-and-type-args> # identifier + type arguments (if any)\n        \\g<identifier>\\s*\n        (?<type-args>\\s*\\[(?:[^\\[\\]]|\\g<type-args>)+\\]\\s*)?\n      )\n      (?:\\s*\\.\\s*\\g<name-and-type-args>)* | # Are there any more names being dotted into?\n      (?<tuple>\\s*\\((?:[^\\(\\)]|\\g<tuple>)+\\))\n    )\n    (?:\\s*\\*\\s*)* # pointer suffix?\n    (?:\\s*\\?\\s*)? # nullable suffix?\n    (?:\\s*\\[(?:\\s*,\\s*)*\\]\\s*)* # array suffix?\n  )\n)\n(?:\\b(?<tuple-name>\\g<identifier>)\\b)?",
      "captures": {
        "1": {
          "patterns": [
            {
              "include": "#type"
            }
          ]
        },
        "6": {
          "name": "entity.name.variable.tuple-element.nemerle"
        }
      }
    },
    "type-builtin": {
      "match": "\\b(bool|byte|char|decimal|double|float|int|long|object|sbyte|short|string|uint|ulong|ushort|void)\\b",
      "captures": {
        "1": {
          "name": "keyword.type.nemerle"
        }
      }
    },
    "type-name": {
      "patterns": [
        {
          "match": "([_[:alpha:]][_[:alnum:]]*)\\s*(\\:\\:)",
          "captures": {
            "1": {
              "name": "entity.name.type.alias.nemerle"
            },
            "2": {
              "name": "punctuation.separator.coloncolon.nemerle"
            }
          }
        },
        {
          "match": "([_[:alpha:]][_[:alnum:]]*)\\s*(\\.)",
          "captures": {
            "1": {
              "name": "entity.name.type.nemerle"
            },
            "2": {
              "name": "punctuation.accessor.nemerle"
            }
          }
        },
        {
          "match": "(\\.)\\s*([_[:alpha:]][_[:alnum:]]*)",
          "captures": {
            "1": {
              "name": "punctuation.accessor.nemerle"
            },
            "2": {
              "name": "entity.name.type.nemerle"
            }
          }
        },
        {
          "name": "entity.name.type.nemerle",
          "match": "[_[:alpha:]][_[:alnum:]]*"
        }
      ]
    },
    "type-arguments": {
      "begin": "\\[",
      "beginCaptures": {
        "0": {
          "name": "punctuation.definition.typeparameters.begin.nemerle"
        }
      },
      "end": "\\]",
      "endCaptures": {
        "0": {
          "name": "punctuation.definition.typeparameters.end.nemerle"
        }
      },
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#type"
        },
        {
          "include": "#punctuation-comma"
        }
      ]
    },
    "type-array-suffix": {
      "begin": "\\[",
      "beginCaptures": {
        "0": {
          "name": "punctuation.squarebracket.open.nemerle"
        }
      },
      "end": "\\]",
      "endCaptures": {
        "0": {
          "name": "punctuation.squarebracket.close.nemerle"
        }
      },
      "patterns": [
        {
          "include": "#punctuation-comma"
        }
      ]
    },
    "type-nullable-suffix": {
      "match": "\\?",
      "captures": {
        "0": {
          "name": "punctuation.separator.question-mark.nemerle"
        }
      }
    },
    "operator-assignment": {
      "name": "keyword.operator.assignment.nemerle",
      "match": "(?<!=|!)(=)(?!=)"
    },
    "punctuation-comma": {
      "name": "punctuation.separator.comma.nemerle",
      "match": ","
    },
    "punctuation-semicolon": {
      "name": "punctuation.terminator.statement.nemerle",
      "match": ";"
    },
    "punctuation-accessor": {
      "name": "punctuation.accessor.nemerle",
      "match": "\\."
    },
    "preprocessor": {
      "name": "meta.preprocessor.nemerle",
      "begin": "^\\s*(\\#)\\s*",
      "beginCaptures": {
        "1": {
          "name": "punctuation.separator.hash.nemerle"
        }
      },
      "end": "(?<=$)",
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#preprocessor-define-or-undef"
        },
        {
          "include": "#preprocessor-if-or-elif"
        },
        {
          "include": "#preprocessor-else-or-endif"
        },
        {
          "include": "#preprocessor-warning-or-error"
        },
        {
          "include": "#preprocessor-region"
        },
        {
          "include": "#preprocessor-endregion"
        },
        {
          "include": "#preprocessor-load"
        },
        {
          "include": "#preprocessor-r"
        },
        {
          "include": "#preprocessor-line"
        },
        {
          "include": "#preprocessor-pragma-warning"
        },
        {
          "include": "#preprocessor-pragma-checksum"
        }
      ]
    },
    "preprocessor-define-or-undef": {
      "match": "\\b(?:(define)|(undef))\\b\\s*\\b([_[:alpha:]][_[:alnum:]]*)\\b",
      "captures": {
        "1": {
          "name": "keyword.preprocessor.define.nemerle"
        },
        "2": {
          "name": "keyword.preprocessor.undef.nemerle"
        },
        "3": {
          "name": "entity.name.variable.preprocessor.symbol.nemerle"
        }
      }
    },
    "preprocessor-if-or-elif": {
      "begin": "\\b(?:(if)|(elif))\\b",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.if.nemerle"
        },
        "2": {
          "name": "keyword.preprocessor.elif.nemerle"
        }
      },
      "end": "(?=$)",
      "patterns": [
        {
          "include": "#comment"
        },
        {
          "include": "#preprocessor-expression"
        }
      ]
    },
    "preprocessor-else-or-endif": {
      "match": "\\b(?:(else)|(endif))\\b",
      "captures": {
        "1": {
          "name": "keyword.preprocessor.else.nemerle"
        },
        "2": {
          "name": "keyword.preprocessor.endif.nemerle"
        }
      }
    },
    "preprocessor-warning-or-error": {
      "match": "\\b(?:(warning)|(error))\\b\\s*(.*)(?=$)",
      "captures": {
        "1": {
          "name": "keyword.preprocessor.warning.nemerle"
        },
        "2": {
          "name": "keyword.preprocessor.error.nemerle"
        },
        "3": {
          "name": "string.unquoted.preprocessor.message.nemerle"
        }
      }
    },
    "preprocessor-load": {
      "begin": "\\b(load)\\b",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.load.nemerle"
        }
      },
      "end": "(?=$)",
      "patterns": [
        {
          "match": "\\\"[^\"]*\\\"",
          "captures": {
            "0": {
              "name": "string.quoted.double.nemerle"
            }
          }
        }
      ]
    },
    "preprocessor-r": {
      "begin": "\\b(r)\\b",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.r.nemerle"
        }
      },
      "end": "(?=$)",
      "patterns": [
        {
          "match": "\\\"[^\"]*\\\"",
          "captures": {
            "0": {
              "name": "string.quoted.double.nemerle"
            }
          }
        }
      ]
    },
    "preprocessor-region": {
      "match": "\\b(region)\\b\\s*(.*)(?=$)",
      "captures": {
        "1": {
          "name": "keyword.preprocessor.region.nemerle"
        },
        "2": {
          "name": "string.unquoted.preprocessor.message.nemerle"
        }
      }
    },
    "preprocessor-endregion": {
      "match": "\\b(endregion)\\b",
      "captures": {
        "1": {
          "name": "keyword.preprocessor.endregion.nemerle"
        }
      }
    },
    "preprocessor-line": {
      "begin": "\\b(line)\\b",
      "beginCaptures": {
        "1": {
          "name": "keyword.preprocessor.line.nemerle"
        }
      },
      "end": "(?=$)",
      "patterns": [
        {
          "match": "\\b(?:(default|hidden))",
          "captures": {
            "1": {
              "name": "keyword.preprocessor.default.nemerle"
            },
            "2": {
              "name": "keyword.preprocessor.hidden.nemerle"
            }
          }
        },
        {
          "match": "[0-9]+",
          "captures": {
            "0": {
              "name": "constant.numeric.decimal.nemerle"
            }
          }
        },
        {
          "match": "\\\"[^\"]*\\\"",
          "captures": {
            "0": {
              "name": "string.quoted.double.nemerle"
            }
          }
        }
      ]
    },
    "preprocessor-pragma-warning": {
      "match": "\\b(pragma)\\b\\s*\\b(warning)\\b\\s*\\b(?:(disable)|(restore))\\b(\\s*[0-9]+(?:\\s*,\\s*[0-9]+)?)?",
      "captures": {
        "1": {
          "name": "keyword.preprocessor.pragma.nemerle"
        },
        "2": {
          "name": "keyword.preprocessor.warning.nemerle"
        },
        "3": {
          "name": "keyword.preprocessor.disable.nemerle"
        },
        "4": {
          "name": "keyword.preprocessor.restore.nemerle"
        },
        "5": {
          "patterns": [
            {
              "match": "[0-9]+",
              "captures": {
                "0": {
                  "name": "constant.numeric.decimal.nemerle"
                }
              }
            },
            {
              "include": "#punctuation-comma"
            }
          ]
        }
      }
    },
    "preprocessor-pragma-checksum": {
      "match": "\\b(pragma)\\b\\s*\\b(checksum)\\b\\s*(\\\"[^\"]*\\\")\\s*(\\\"[^\"]*\\\")\\s*(\\\"[^\"]*\\\")",
      "captures": {
        "1": {
          "name": "keyword.preprocessor.pragma.nemerle"
        },
        "2": {
          "name": "keyword.preprocessor.checksum.nemerle"
        },
        "3": {
          "name": "string.quoted.double.nemerle"
        },
        "4": {
          "name": "string.quoted.double.nemerle"
        },
        "5": {
          "name": "string.quoted.double.nemerle"
        }
      }
    },
    "preprocessor-expression": {
      "patterns": [
        {
          "begin": "\\(",
          "beginCaptures": {
            "0": {
              "name": "punctuation.parenthesis.open.nemerle"
            }
          },
          "end": "\\)",
          "endCaptures": {
            "0": {
              "name": "punctuation.parenthesis.close.nemerle"
            }
          },
          "patterns": [
            {
              "include": "#preprocessor-expression"
            }
          ]
        },
        {
          "match": "\\b(?:(true)|(false)|([_[:alpha:]][_[:alnum:]]*))\\b",
          "captures": {
            "1": {
              "name": "constant.language.boolean.true.nemerle"
            },
            "2": {
              "name": "constant.language.boolean.false.nemerle"
            },
            "3": {
              "name": "entity.name.variable.preprocessor.symbol.nemerle"
            }
          }
        },
        {
          "match": "(==|!=)|(\\!|&&|\\|\\|)",
          "captures": {
            "1": {
              "name": "keyword.operator.comparison.nemerle"
            },
            "2": {
              "name": "keyword.operator.logical.nemerle"
            }
          }
        }
      ]
    },
    "comment": {
      "patterns": [
        {
          "name": "comment.block.nemerle",
          "begin": "/\\*",
          "beginCaptures": {
            "0": {
              "name": "punctuation.definition.comment.nemerle"
            }
          },
          "end": "\\*/",
          "endCaptures": {
            "0": {
              "name": "punctuation.definition.comment.nemerle"
            }
          }
        },
        {
          "begin": "(^\\s+)?(?=//)",
          "beginCaptures": {
            "1": {
              "name": "punctuation.whitespace.comment.leading.nemerle"
            }
          },
          "end": "(?=$)",
          "patterns": [
            {
              "name": "comment.block.documentation.nemerle",
              "begin": "(?<!/)///(?!/)",
              "beginCaptures": {
                "0": {
                  "name": "punctuation.definition.comment.nemerle"
                }
              },
              "end": "(?=$)",
              "patterns": [
                {
                  "include": "#xml-doc-comment"
                }
              ]
            },
            {
              "name": "comment.line.double-slash.nemerle",
              "begin": "(?<!/)//(?!/)",
              "beginCaptures": {
                "0": {
                  "name": "punctuation.definition.comment.nemerle"
                }
              },
              "end": "(?=$)"
            }
          ]
        }
      ]
    },
    "xml-doc-comment": {
      "patterns": [
        {
          "include": "#xml-comment"
        },
        {
          "include": "#xml-character-entity"
        },
        {
          "include": "#xml-cdata"
        },
        {
          "include": "#xml-tag"
        }
      ]
    },
    "xml-tag": {
      "name": "meta.tag.nemerle",
      "begin": "(?x)\n(</?)\n(\n  (?:\n    ([-_[:alnum:]]+)\n    (:)\n  )?\n  ([-_[:alnum:]]+)\n)",
      "beginCaptures": {
        "1": {
          "name": "punctuation.definition.tag.nemerle"
        },
        "2": {
          "name": "entity.name.tag.nemerle"
        },
        "3": {
          "name": "entity.name.tag.namespace.nemerle"
        },
        "4": {
          "name": "punctuation.separator.colon.nemerle"
        },
        "5": {
          "name": "entity.name.tag.localname.nemerle"
        }
      },
      "end": "(/?>)",
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.tag.nemerle"
        }
      },
      "patterns": [
        {
          "include": "#xml-attribute"
        }
      ]
    },
    "xml-attribute": {
      "patterns": [
        {
          "match": "(?x)\n(?:^|\\s+)\n(\n  (?:\n    ([-_[:alnum:]]+)\n    (:)\n  )?\n  ([-_[:alnum:]]+)\n)\n(=)",
          "captures": {
            "1": {
              "name": "entity.other.attribute-name.nemerle"
            },
            "2": {
              "name": "entity.other.attribute-name.namespace.nemerle"
            },
            "3": {
              "name": "punctuation.separator.colon.nemerle"
            },
            "4": {
              "name": "entity.other.attribute-name.localname.nemerle"
            },
            "5": {
              "name": "punctuation.separator.equals.nemerle"
            }
          }
        },
        {
          "include": "#xml-string"
        }
      ]
    },
    "xml-cdata": {
      "name": "string.unquoted.cdata.nemerle",
      "begin": "<!\\[CDATA\\[",
      "beginCaptures": {
        "0": {
          "name": "punctuation.definition.string.begin.nemerle"
        }
      },
      "end": "\\]\\]>",
      "endCaptures": {
        "0": {
          "name": "punctuation.definition.string.end.nemerle"
        }
      }
    },
    "xml-string": {
      "patterns": [
        {
          "name": "string.quoted.single.nemerle",
          "begin": "\\'",
          "beginCaptures": {
            "0": {
              "name": "punctuation.definition.string.begin.nemerle"
            }
          },
          "end": "\\'",
          "endCaptures": {
            "0": {
              "name": "punctuation.definition.string.end.nemerle"
            }
          },
          "patterns": [
            {
              "include": "#xml-character-entity"
            }
          ]
        },
        {
          "name": "string.quoted.double.nemerle",
          "begin": "\\\"",
          "beginCaptures": {
            "0": {
              "name": "punctuation.definition.string.begin.nemerle"
            }
          },
          "end": "\\\"",
          "endCaptures": {
            "0": {
              "name": "punctuation.definition.string.end.nemerle"
            }
          },
          "patterns": [
            {
              "include": "#xml-character-entity"
            }
          ]
        }
      ]
    },
    "xml-character-entity": {
      "patterns": [
        {
          "name": "constant.character.entity.nemerle",
          "match": "(?x)\n(&)\n(\n  (?:[[:alpha:]:_][[:alnum:]:_.-]*)|\n  (?:\\#[[:digit:]]+)|\n  (?:\\#x[[:xdigit:]]+)\n)\n(;)",
          "captures": {
            "1": {
              "name": "punctuation.definition.constant.nemerle"
            },
            "3": {
              "name": "punctuation.definition.constant.nemerle"
            }
          }
        },
        {
          "name": "invalid.illegal.bad-ampersand.nemerle",
          "match": "&"
        }
      ]
    },
    "xml-comment": {
      "name": "comment.block.nemerle",
      "begin": "<!--",
      "beginCaptures": {
        "0": {
          "name": "punctuation.definition.comment.nemerle"
        }
      },
      "end": "-->",
      "endCaptures": {
        "0": {
          "name": "punctuation.definition.comment.nemerle"
        }
      }
    }
  }
}